## DML 성능에 영향을 미치는 요소
DML 성능에 영향을 미치는 요소는 다음과 같다.
- 인덱스
- 무결성 제약
- 조건절
- 서브쿼리
- Redo 로깅
- Undo 로깅
- Lock
- 커밋

### 인덱스와 DML 성능

인덱스는 정렬된 자료구조이므로 레코드를 삽입할 때 `수직적 탐색을 통해 입력할 블록을 찾아야 한다.` 인덱스에 입력하는 과정이 더 복잡하므로 DML 성능에 미치는 영향도 크다.

레코드를 삭제할 때도 마찬가지다. 테이블에서 레코드 하나를 삭제하면, 인덱스 레코드를 모두 찾아서 삭제해 줘야 한다. 변경을 할 때는 변경된 컬럼을 참조하는 인덱스만 찾아서 변경해 주면 된다. 그 대신, 테이블에서 한 건 변경할 때 마다 인덱스에는 두 개의 오퍼레이션이(삭제, 삽입) 발생한다.

인덱스 개수가 DML 성능에 미치는 영향이 매우 큰 만큼, 인덱스 설계에 심혈을 기울여야 한다. 핵심 트랜잭션 테이블에서 인덱스 하나라도 줄이면 TPS(Transaction Per Second)는 그만큼 향상된다.

> 시스템 마다 다르지만 인덱스 1개에 100만 건 데이터를 넣을 때는 약 5초, 인덱스 3개에 100만 건 데이터를 넣을 때는 약 40초 정도로 8배 정도의 성능 차이가 발생했다.

### 무결성 제약과 DML 성능
데이터베이스에 논리적으로 의미 있는 자료만 저장되게 하는 데이터 무결성 규칙으로는 네 가지가 있다.
- 개체 무결성
- 참조 무결성
- 도메인 무결성
- 사용자 정의 무결성

이들 규칙을 애플리케이션으로 구현할 수도 있지만, DBMS에서 PK, FK, Check, Not Null 같은 제약을 설정하면 더 완벽하게 데이터 무결성을 지켜낼 수 있다.

PK, FK 제약은 Check, Not Null 제약보다 `성능에 더 큰 영향을 미친다.` Check, Not Null은 정의한 제약 조건을 준수하는지만 확인하면 되지만, `PK, FK 제약은 실제 데이터를 조회해 봐야 하기 때문`이다.

> 시스템 마다 다르지만 인덱스 2개를 기준으로 PK 제약과 인덱스가 존재하는 경우 약 40초, PK 제약이 존재하고 인덱스가 존재하지 않는 경우 약 5초, 둘 다 존재하지 않는 경우 약 1.3초 정도의 성능 차이가 발생했다.

### 조건절과 DML 성능
SELECT 문과 실행계획이 다르지 않기 때문에 인덱스 튜닝 원리를 그대로 적용할 수 있다.

### 서브쿼리와 DML 성능
서브쿼리 역시 SELECT 문과 실행계획이 다르지 않기 때문에 인덱스 튜닝 원리를 그대로 적용할 수 있다.

### Redo 로깅과 DML 성능
오라클은 데이터파일과 컨트롤 파일에 가해지는 `모든 변경사항을 Redo 로그에 기록`한다. Redo 로그는 트랜잭션 데이터가 어떤 이유에서건 유실됐을 때, 트랜잭션을 제한함으로써 `유실 이전 상태로 복구하는 데 사용`된다.

DML을 수행할 때마다 Redo 로그를 생성해야 하므로 Redo 로깅은 DML 성능에 영향을 미친다. 

### Redo 로그의 용도
Redo 로그는 아래 세 가지 목적에 사용된다.
1. Database Recovery
2. Cache Recovery
3. Fast Commit

첫째, Redo 로그는 물리적으로 디스크가 깨지는 등의 Media Fail 발생 시 데이터베이스를 복구하기 위해 사용한다. 

둘째, Redo 로그는 'Cache Recovery'를 위해 사용하며 다른 말로 'Instance Recovery'라고도 한다. 버퍼캐시는 휘발성이다. 캐시에 저장된 변경사항이 디스크에 문제가 생겨 비정상적으로 종료되면, 그때까지 작업내용을 모두 잃게된다. 이러한 트랜잭션 데이터 유실에 대비하기 위해 Redo 로그를 남긴다.

마지막으로 Redo 로그는 'Fast Commit'을 위해 사용한다. 변경된 메모리 버퍼블록을 디스크 상의 데이터 블록에 반영하는 작업은 랜덤 액세스 방식으로 이루어지므로 매우 느리다. 반면 로그는 Append 방식으로 기록하므로 상대적으로 빠르다. 따라서 트랜잭션에 의한 변경사항을 우선 Append 방식으로 빠르게 로그 파일에 기록하고, 변경된 메모리 버퍼블록과 데이터파일 블록 간 동기화는 적절한 수단을 이용해 나중에 `배치 방식으로 일괄 수행`한다.

### Undo 로깅과 DML 성능
`Redo는 트랜잭션을 재현`함으로써 과거를 현재 상태로 되돌리는 데 사용하고, `Undo는 트랜잭션을 롤백`함으로써 현재를 과거 상태로 되돌리는 데 사용한다.

따라서 Redo에는 트랜잭션을 재현하는 데 필요한 정보를 로깅하고, Undo에는 변경된 블록을 이전 상태로 되돌리는 데 필요한 정보를 로깅한다.

DML을 수행할 때마다 Undo를 생성해야 하므로 Undo 로깅은 DML 성능에 영향을 미친다. 

### Undo의 용도와 MVCC 모델
오라클은 데이터를 입력, 수정, 삭제할 때마다 Undo 세그먼트에 기록을 남긴다. Undo 데이터를 기록한 공간은 해당 트랜잭션이 커밋하는 순간, 다른 트랜잭션이 재사용할 수 있는 상태로 바뀐다. `가장 오래 전에 커밋한 Undo 공간부터 재사용하므로 Undo 데이터가 곧바로 사라지진 않겠지만, 언젠가 다른 트랜잭션 데이터로 덮어쓰이면서 사라질 수 밖에 없다.`

Undo에 기록한 데이터는 아래 세 가지 목적에 사용된다.
1. Transaction Rollback
2. Transaction Recovery
3. Read Consistency

첫째, 트랜잭션에 의한 변경사항을 최종 커밋하지 않고 롤백하고자 할 때 Undo 데이터를 이용한다.

둘째, Instance Crash 발생 후 Redo를 이용해 roll forward 단계가 완료되면 최종 커밋되지 않은 변경사항까지 모두 복구된다. 따라서 시스템이 셧다운된 시점에 아직 커밋되지 않았던 트랜잭션들을 모두 롤백해야 하는데, 이때 Undo 데이터를 사용한다.

마지막으로, Undo 데이터는 '읽기 일관성'을 위해 사용한다. SQL 튜닝 관점에서 주목할 내용은 읽기 일관성이다. 읽기 일관성을 위해 Consistent 모드로 데이터를 읽는 오라클에선 동시 트랜잭션이 많을수록 블록 I/O가 증가하면서 성능 저하로 이어지기 때문이다.

## Lock과 DML 성능
Lock은 DML 성능에 매우 크고 직접적인 영향을 미친다. Lock을 필요 이상으로 자주, 길게 사용하거나 레벨을 높일수록 DML 성능은 느려진다. 그렇다고 Lock을 너무 적게, 짧게 사용하거나 필요한 레벨 이하로 낮추면 데이터 품질이 나빠진다. 성능과 데이터 품질이 모두 중요한데, 이 둘은 트레이드 오프 관계여서 어렵다. 두 마리 토끼를 다 잡으려면 매우 세심한 동시성 제어가 필요하다.

동시성 제어란, 동시에 실행되는 트랜잭션 수를 최대화 하면서도 입력, 수정, 삭제, 검색 시 데이터 무결성을 유지하기 위해 노력하는 것을 말한다.

## 커밋과 DML 성능
커밋은 DML과 별개로 실행하지만, DML을 끝내려면 커밋까지 완료해야 하므로 서로 밀접한 관련이 있다. 특히 DML이 Lock에 의해 블로킹된 경우, 커밋은 DML 성능과 직결된다. DML을 완료할 수 있게 `Lock을 푸는 열쇠가 바로 커밋`이기 때문이다.

모든 DBMS가 Fast Commit을 구현하고 있다. 구현방식은 서로 다르지만, `갱신한 데이터가 아무리 많아도 커밋만큼은 빠르게 처리한다는 점은 같다.`

커밋의 내부 메커니즘은 다음과 같다.

### DB 버퍼캐시
DB에 접속한 사용자를 대신해 모든 일을 처리하는 서버 프로세스는 버퍼캐시를 통해 데이터를 읽고 쓴다. 버퍼캐시에서 변경된 블록을 모아 주기적으로 데이터파일에 일괄 기록하는 작업은 DBWR(Database Writer) 프로세스가 맡는다.

### Redo 로그버퍼
`버퍼캐시는 휘발성`이므로 DBWR 프로세스가 Dirty 블록들을 데이터파일에 반영할 때까지 불안한 상태라고 생각할 수 있다. 하지만, 버퍼캐시에 가한 변경사항을 Redo 로그에도 기록해 두었으므로 안심해도 된다. `버퍼캐시 데이터가 유실되더라도 Redo 로그를 이용해 언제든 복구할 수 있기 때문`이다.

그런데 Redo 로그도 파일이기 때문에 디스크 I/O가 발생하므로 느리다. 따라서 오라클은 로그버퍼를 이용한다. `Redo 로그파일에 기록하기 전에 먼저 로그버퍼에 기록하는 방식`이다.

### 트랜잭션 데이터 저장 과정
한 트랜잭션이 데이터를 변경하고 커밋하는 과정, 그리고 변경된 블록을 데이터파일에 기록하는 과정은 다음과 같다.
1. DML 문을 실행하면 Redo 로그버퍼에 변경사항을 기록한다.
2. 버퍼블록에서 데이터를 변경한다. 물론, 버퍼캐시에서 블록을 찾지 못하면, 데이터파일에서 읽는 작업부터 한다.
3. 커밋한다.
4. LGWR(Log Writer) 프로세스가 Redo 로그 버퍼 내용을 Redo 로그 파일에 일괄 저장한다.
5. DBWR 프로세스가 버퍼 캐시에 변경된 블록을 데이터 파일에 일괄 저장한다.

오라클은 데이터를 변경하기 전에 항상 로그부터 기록한다.

Redo 로그마저도 휘발성 로그버퍼에 기록한다면 트랜잭션 데이터를 안전하게 지킬 수 있을까?

잠자던 DBWR와 LGWR 프로세스는 '주기적으로' 깨어나 각각 Dirty 블록과 Redo 로그버퍼를 파일에 기록한다. LGWR 프로세스는 서버 프로세스가 커밋을 발행했다고 '신호를 보낼때도' 깨어나서 활동을 시작한다. '적어도 커밋시점에는' Redo 로그버퍼 내용을 로그파일에 기록한다는 뜻이다. 이를 'Log Force at Commit'이라고 부른다.

서버 프로세스가 변경한 버퍼블록들을 디스크에 기록하지 않았더라도 커밋 시점에 Redo 로그를 디스크에 안전하게 기록했다면, 그 순간부터 트랜잭션의 영속성은 보장된다.

### '커밋=저장 버튼'
문서를 작성할 때 워드프로세서는 저장 버튼을 눌러야 비로소 디스크 파일에 저장되며, 저장을 완료할 때까지 사용자는 작업을 계속할 수 없다.

데이터베이스 트랜잭션을 문서 작업에 비유하면, 커밋 문서 작업 도중에 '저장' 버튼을 누르는 것과 같다. 서버 프로세스가 그때까지 했던 작업을 디스크에 기록하라는 명령어인 셈이다. 저장을 완료할 때까지 서버 프로세스는 다음 작업을 진행할 수 없다. Redo 로그버퍼에 기록된 내용을 디스크에 기록하도록 LGWR 프로세스에 신호를 보낸 후 작업을 완료했다는 신호를 받아야 다음 작업을 진행할 수 있다. Sync 방식이다. `LGWR 프로세스가 Redo 로그를 기록하는 작업은 디스크 I/O 작업`이다. 커밋은 그래서 생각보다 느리다

## 데이터베이스 Call과 성능
SQL은 아래 세 단계로 나누어 실행된다.
- Parse Call: `SQL 파싱과 최적화를 수행하는 단계다.` SQL과 실행계획을 라이브러리 캐시에서 찾으면, 최적화 단계는 생략할 수 있다.
- Execute Call: `말 그대로 SQL을 실행하는 단계다.` DML은 이 단계에서 모든 과정이 끝나지만, SELECT 문은 Fetch 단계를 거친다.
- Fetch Call: `데이터를 읽어서 사용자에게 결과집합을 전송하는 고자ㅓㅇ으로 SELECT 문에서만 나타난다.` 전송할 데이터가 많을 때는 Fetch Call이 여러 번 발생한다.

Call의 발생 위치에 따라 User Call과 Recursive Call로 나눌 수 있다.
- User Call: `네트워크를 경유해 DBMS 외부로부터 인입되는 Call이다.` 3-Tier 아키텍처에서 User Call은 WAS 서버에서 발생하는 Call이다.
- Recursive Call: `DBMS 내부에서 발생하는 Call이다.` 사용자 정의 함수/프로시저/트리거에 내장된 SQL을 실행할 때 발생하는 Call이다.

User Call이든 Recursive Call이든, SQL을 실행할 때마다 Parse, Execute, Fetch Call 단계를 거친다. 데이터베이스 Call이 많으면 성능이 느릴 수 밖에 없는데, `특히 User Call이 성능에 미치는 영향이 매우 크다.`

> PL/SQL 프로그램에서 100만 번 루프를 돌면서 건건이 INSERT문을 실행할 경우 루프를 돌면서 건건이 Call이 발생했지만, 네트워크를 경유하지 않는 Recursive Call이므로 약 29초 만에 수행을 마쳤다. 반면 자바 프로그램으로 수행하여 네트워크를 경유하는 User Call이 발생하는 경우 약 218초가 걸리며 성능이 급격히 나빠졌다.  

### One SQL의 중요성
Insert Into Select 구문과 같이 One SQL을 사용하면 단 한 번의 Call로 처리하니 약 1.46초 만에 수행을 마쳤다. `업무 로직이 복잡하지 않다면 가급적 One SQL로 구현하려고 노력해야 한다.`

## Array Processing 활용
실무에서 복잡한 업무 로직 때문에 One SQL로 구현하는 일이 쉽지 않은데, 그럴 때 `Array Processing 기능을 활용하면 One SQL로 구현하지 않고도 Call 부하를 획기적으로 줄일 수 있다.`

절차적으로 수행할 때 약 30초 걸리던 PL/SQL 프로그램이 약 4초 만에 수행을 마쳤다.

절차적으로 수행할 때 218초 걸리던 자바 프로그램이 약 12초 만에 수행을 마쳤다. 만 번에 한 번씩 INSERT 하도록 구현함으로써 Call을 백 번으로 줄였기 때문이다.

`Call을 단 하나로 줄이지 못하더라도 Array Processing을 활용해 10 ~ 100번 수준으로 줄일 수 있다면 One SQL에 준하는 성능 효과를 얻을 수 있다.`

## 인덱스 및 제약 해제를 통한 대량 DML 튜닝
인덱스와 무결성 제약 조건은 DML 성능에 큰 영향을 끼친다. 그렇다고 온라인 트랜잭션 처리 시스템에서 이들 기능을 해제할 순 없다. 반면, `동시 트랜잭션 없이 대량 데이터를 적재하는 배치 프로그램에서는 이들 기능을 해제함으로써 큰 성능개선 효과를 얻을 수 있다.`

100만 건의 데이터를 입력할 경우 
= PK 제약과 인덱스가 총 두 개인 경우 약 1분 19초가 걸렸다. 
- PK 제약과 인덱스 해제 
  - PK 제약에 Unique 인덱스를 사용한 경우 약 6초가 걸렸다.
  - PK 제약에 Non-Unique 인덱스를 사용한 경우 약 18초가 걸렸다.

## 수정가능 조인 뷰
다른 테이블과 조인이 필요할 때 전통적인 UPDATE 문을 사용하면 비효율을 완전히 해소할 수 없다.

수정가능 조인 뷰를 활용하면 참조 테이블과 두 번 조인하는 비효율을 없앨 수 있다.

'조인 뷰'는 FROM 절에 두 개 이상 테이블을 가진 뷰를 가리키며, `'수정가능 조인 뷰'는 말 그대로 입력, 수정, 삭제가 허용되는 조인 뷰`를 말한다.

### 키 보존 테이블이란?
'키 보존 테이블'이란, 조인된 결과집합을 통해서도 중복 값 없이 Unique 하게 식별이 가능한 테이블을 말한다.

## Merge 문 활용
오라클 9i에서 MERGE 문이 도입됐다.

MERGE 문은 Left Outer 방식으로 조인하여 조인에 성공하면 UPDATE, 실패하면 INSERT 한다.

### Optional Clauses
UPDATE와 INSERT를 선택적으로 처리할 수 있다.

### Conditional Operations
ON 절에 기술한 조인문 외에 추가로 조건절을 기술할 수도 있다.

### DELTE Clauses
이미 저장된 데이터를 조건에 따라 지우는 기능도 제공한다.
