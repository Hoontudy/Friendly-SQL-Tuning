# SQL

SQL 은 `Structured Query Language` 의 줄임말로 직역하면 구조적 질의 언어이다. **SQL 은 관계형 데이터베이스 시스템에서 데이터를 관리 및 가공하기 위해 설계된 언어이다.**

# SQL 최적화

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 `SQL 최적화`라고 한다.
> 💡프로시저란 데이터베이스의 일련의 작업에 대한 절차를 DBMS 에 저장한 것으로 영구저장 모듈이라고 불린다.

### SQL 을 실행하기 전 최적화 과정을 세분화하면 다음과 같다.

1. `SQL 파싱`
    - 사용자로부터 SQL 을 전달 받으면 가장 먼저 SQL 파서가 해당 SQL 을 파싱한다. 파싱 과정은 다음과 같다.
        - 파싱 트리 생성: SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리를 생성한다.
        - Syntax 체크: SQL 문법이 올바른지 체크한다. ex) 존재하지 않는 키워드 입력, 키워드의 순서
        - Semantic 체크: 의미상 오류가 없는지를 체크한다. ex) 테이블 접근 권한, 올바르지 않은 컬럼명 입력
2. `SQL 최적화`
    - 옵티마이저가 SQL 최적화를 담당한다. 옵티마이저는 미리 수집한 다양한 정보를 바탕으로 다양한 실행경로를 생성하여 비교를 통해 가장 효율적인 하나를 선택한다.
3. `로우 소스 생성`
    - 옵티마이저에 의해 선택된 실행경로를 실행 가능한 코드 또는 프로시저의 형태로 포매팅하는 단계이다. 로우 소스 생성기가 이 역할을 맡는다.

# SQL 옵티마이저

옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 경로를 선택해주는 `DBMS 의 핵심 엔진`이다. 옵티마이저가 실행계획을 선택하는 단계는 다음과 같다.
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2. 데이터 딕셔너리에 미리 수집해 둔 정보들을 이용하여 각 실행계획의 비용을 비교한다.
3. 그 중 가장 효율적인 실행계획을 선택한다.

# 실행계획과 비용
DBMS 는 옵티마이저가 생성한 처리절차를 트리 구조로 표현하여 사용자가 볼 수 있도록 제공해준다. 이것을 `실행계획`이라고 한다.

실행계획을 덕분에 사용자가 작성한 SQL 이 테이블, 인덱스를 스캔하는지, 만약 인덱스를 스캔한다면 어떤 인덱스를 스캔하는지 확인할 수 있다.


### 옵티마이저가 실행계획을 세우는 근거는 무엇일까?
옵티마이저는 `비용(coast)`이라는 개념을 사용한다. 비용이란 쿼리가 수행되는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요 시간을 표현한 값이다. 옵티마이저는 이 비용이 가장 적은 처리절차를 선택하여 실행계획을 세우게 된다.

하지만 비용은 옵티마이저가 여러 정보를 통해 예상한 값이다. 그렇기 때문에 실제 수행할 때 발생되는 I/O 또는 시간과 차이가 발생한다.

# 옵티마이저 힌트
옵티마이저는 보편적으로 최적의 실행계획을 선택해준다. 하지만 옵티마이저는 `비현실적인 가정`, `하드웨어 성능`, `부정확한 통계정보` 등의 문제로 인한 한계가 존재한다. 때문에 항상 완벽한 것은 아니다. 이러한 경우 옵티마이저 힌트를 이용하여 개발자가 직접 실행계획을 설정할 수 있다.

힌트를 사용하기 위해서는 주석 기호에 `+` 를 붙이면 된다.

```SQL
SELECT /*+ INDEX(m  member_pk) */
     name, age, created_at
FROM MEMBER as m
WHERE m.id = 1
```
아래와 같은 방식도 있지만 주석처리로 인한 줄바꿈 이슈가 발생할 수 있기 때문에 권장하지 않는다.
```SQL
SELECT --+ INDEX(m  member_pk)
     name, age, created_at
FROM MEMBER as m
WHERE m.id = 1
```

### 힌트 사용 시 주의사항
- 힌트 안에 인자를 나열할 땐 `,` 를 사용할 수 있지만, 힌트와 힌트 상에 사용하면 안된다.
```SQL
/*+ INDEX(A A_X01) INDEX(B, B_X01) */ -> 모두 유효
/*+ INDEX(C), FULL(D) */ -> 첫 번째 힌트만 유효
```
- 테이블을 지정할 때 아래와 같이 스키마명까지 명시하면 안된다.
```SQL
SELECT /*+ FULL(MEMBER.NAME) */ -> 무효
FROM MEMBER
```
- FROM 절 테이블명에 ALIAS 를 지정했다면, 힌트에도 반드시 ALIAS 를 사용해야 한다. 그렇지 않을 경우 해당 힌트는 무시된다.
```SQL
SELECT /*+ FULL(NAME) */ -> 무효
FROM MEMBER as m
```
