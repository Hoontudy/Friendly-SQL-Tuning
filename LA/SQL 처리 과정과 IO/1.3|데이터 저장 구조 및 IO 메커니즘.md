# SQL 이 느린 이유
SQL 이 느린 이유는 십중팔구 `디스크 I/O` 때문이다.

OS 또는 I/O 서브시스템이 I/O 를 처리하는 동안 프로세스는 CPU 를 OS 에 반환하고 I/O 가 완료되기를 기다리며 대기 큐에서 잠을 잔다. 열심히 일을 해야 할 프로세스가 잠을 자고 있으니 I/O 가 많으면 많을수록 성능이 느릴 수 밖에 없다.

이러한 `I/O 문제를 개선하는 것이 곧 SQL 튜닝의 핵심`이다.

# 데이터베이스 저장 구조
![images_berry719_post_ebd86fa6-486d-437a-8db9-cc094f454e55_image](https://user-images.githubusercontent.com/78140516/196655706-878093c4-1f11-46ef-b821-6e1d3e59e53c.png)
(이미지 출처: https://velog.io/@berry719)
### 테이블 스페이스
- 데이터를 저장하기 위해 가장먼저 생성해야 한다.
- 세그먼트를 담는 컨테이너로 여러 개의 데이터파일로 구성된다.

### 세그먼트
- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트다. (테이블, 인덱스, LOB 등)
- 여러 익스텐트로 구성된다.
- 파티션 구조라면 각 파티션이 하나의 세그먼트가 되고, 파티션 구조가 아니라면 테이블, 인덱스는 각각 하나의 세그먼트가 된다.

### 익스텐트
- 공간을 확장하는 단위이며 연속된 블록들의 집합이기도 하다.
- 세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 

### 블록
- 데이터를 읽고 쓰는 단위이다.

### 데이터파일
- 디스크 상의 물리적인 OS 파일이다.

### DBA(Data Block Address)
- 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다. 이 주소값을 DBA 라고 한다.

# 블록 단위 I/O
DBMS 는 `블록` 이라는 단위로 데이터를 읽고 쓴다. 

블록 단위로 데이터를 읽고 쓰기 때문에 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.

기본 설정된 블록의 사이즈는 DBMS 의 종류마다 다르다. (오라클은 기본적으로 8KB 크기의 블록을 사용) 

# 시퀀셜 엑세스 vs 랜덤 엑세스
### 시퀀셜 엑세스
- 논리적 또는 물리적으로 연결된 순서에 따라 순차적으로 블록을 읽는 방식이다.
- 테이블 블록 간에는 서로 논리적인 연결고리를 갖고 있지 않지만 `세그먼트 헤더가 각 익스텐트의 첫 번째 블록 주소 값을 맵으로 관리`한다. 해당 맵에서 각 익스텐트의 블록 정보를 순서대로 읽으면 이것이 곧 `Table Full Scan` 이다.

### 랜덤 엑세스
- 논리적 또는 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다. 
- 원하는 레코드만을 직접 접근하기 때문에 데이터를 더 빨리 검색할 수 있다.

# 논리적 I/O vs 물리적 I/O
### DB 버퍼캐시
- DB 버퍼캐시는 데이터를 읽고 수정하기 위해 `디스크에 존재하는 데이터를 읽어 저장하는 메모리 공간`을 의미한다.
- 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call 을 줄이는데 목적이 있다.
- 라이브러리 캐시가 SQL, 실행계획, 프로시저 등을 캐싱하는 `코드 캐시`라고 한다면, DB 버퍼캐시는 디스크에 존재하는 데이터를 캐싱하는 `데이터 캐시`라고 할 수 있다.

### 논리적 I/O
- SQL 문을 처리하는 과정에서 발생한 총 블록 I/O 를 말한다. 
- `메모리상의 버퍼 캐시를 경유`하므로 메모리 I/O 를 곧 논리적 I/O 라고 봐도 무방하다.

### 물리적 I/O
- 디스크에서 발생한 총 블록 I/O 를 말한다. 
- SQL 처리 도중 읽어야 할 `블록을 버퍼캐시에서 찾지 못한 경우`에 물리적 I/O 가 발생한다. 
- 메모리 I/O 는 전기적 신호인 데 반해, 디스크 I/O 는 물리적 작용이 일어나기 때문에 메모리 I/O 에 비해 상당히 느리다.

### 버퍼캐시 히트율
- 버퍼캐시 히트율은 버퍼캐시의 효율을 측정하는 데 전통적으로 가장 많이 사용해 온 지표이다.
- BCHR = ( ( 논리적 I/O - 물리적 I/O )  / 논리적 I/O ) * 100

BCHR 공식을 아래와 같이 변형하면 `물리적 I/O 가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 논리적 I/O 를 줄여야 한다`는 사실을 알 수 있다.
- 물리적 I/O = 논리적 I/O * ( 100% - BCHR )



### 그렇다면 논리적 I/O 는 어떻게 줄일 수 있을까?
 SQL 을 튜닝해서 총 읽는 블록의 갯수를 줄이면 된다. 논리적 I/O 는 항상 일정하게 발생하지만, SQL 튜닝을 통해 줄일 수 있는 내생변수이다. `논리적 I/O 를 줄임으로써 물리적 I/O 를 줄이는 것이 곧 SQL 튜닝이다.`
 
# Single Block I/O vs Multiblock I/O
비용적, 기술적인 한계 때문에 전체 데이터 중 일부만을 캐시에 적재해서 읽을 수 있다.

### Single Block I/O
- 한 번에 한 블록 씩 요청하여 메모리에 적재하는 방식이다.
- `인덱스는 소량의 데이터를 읽을 때 주로 사용`되는데 이러한 경우 Single Block I/O 방식이 사용된다.

### Multiblock I/O
- 한 번에 여러 블록을 요청하여 메모리에 적재하는 방식이다.
- `한번에 많은 데이터 블록을 읽어야 할 때` 인덱스를 사용하지 않고 테이블을 전체 스캔하는 것이 좋은데 이러한 경우 Multiblock I/O 방식이 사용된다.
- DBMS 블록 사이즈 상관 없이 보통 1MB 단위로 I/O 를 수행한다.

# Table Full Scan vs Index Range Scan
### Index Range Scan
- `인덱스에서 일정량`을 스캔하면서 ROWID 로 테이블 레코드를 찾아가는 방식이다.
- `랜덤 엑세스`와 `Single Block I/O` 방식으로 디스크 블록을 읽는다.

### Table Full Scan
- `테이블에 속한 블록 전체`를 읽어서 사용자가 원하는 데이터를 찾는 방식이다.
- `시퀀셜 엑세스`와 `Multiblock I/O` 방식으로 디스크 블록을 읽는다.

<br/>

**보통 Table Full Scan 방식이 비효율적이라는 고정관념이 있지만 모두 그런것은 아니다. Index Ragne Scan 방식이 더 느린 경우도 존재한다.**

Index Ragne Scan 방식을 사용할 경우 랜덤 엑세스와 Single Block I/O 방식으로 데이터를 읽는다. `만약 캐시에서 블록을 찾을 수 없으면 레코드 하나를 읽기 위해 매번 잠을 자게 된다. 게다가 읽었던 블록을 반복해서 읽는 비효율이 존재`한다. 때문에 많은 데이터를 조회할 때는 Table Full Scan 방식을 사용하는 것이 더 효율적이다.  

> 인덱스를 사용하는 것은 매우 중요하지만 맹신해서는 안되며 상황에 맞는 방식을 사용해야 한다.    

# 캐시 탐색 메커니즘
`Direct Path I/O 를 제외한 모든 블록 I/O 는 메모리 버퍼캐시를 경유`한다.

버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 엑세스하는 방식을 사용한다.

해시 구조의 특징은 다음과 같다.
- 같은 입력 값은 항상 동일한 해시 체인(=버킷)에 연결된다.
- 다른 입력 값이 동일한 해시 체인에 연결될 수 있다.
- 해시 체인 내에서는 정렬이 보장되지 않는다.

### 메모리 공유자원에 대한 엑세스 직렬화
- 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하면 블록 정합성에 문제가 발생할 수 있다.
- 따라서 자원을 공유하는 것 처럼 보여도 내부에서는 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위해 직렬화 메커니즘이 필요하다.

SGA 를 구성하는 서브 캐시마다 별도의 래치가 존재한다.

래치에 의한 경합이 발생할 수 있어 캐시 I/O 도 생각만큼 빠르지 않을 수 있다.

**직렬화 메커니즘에 의한 캐시 경합을 줄이려면, SQL 튜닝을 통해 논리적 I/O 자체를 줄여야 한다.**

### 캐시버퍼 체인 래치
- 해시 체인을 스캔하는 동안 다른 프로세스가 체인 구조를 변경하는 일을 막기 위해 해시 체인 래치가 존재한다.
- 체인 앞쪽에 자물쇠가 있고 자물쇠를 열 수 있는 키를 획득한 프로세스만이 체인으로 진입할 수 있다.

### 버퍼 Lock
- 버퍼블록 자체에도 직렬화 메커니즘이 존재하는데 이것이 버퍼 Lock 이다.
- 래치를 해제한 상태로 버퍼블록 데이터를 읽고 쓰는 도중에 후행 프로세스가 하필 같은 블록에 접근해서 데이터를 읽고 쓴다면 데이터 정합성에 문제가 발생할 수 있다. 이를 방지하기 위해 오라클은 버퍼 Lock 을 사용한다.
- 캐시버퍼 체인 래치를 해제하기 전에 버퍼 헤더에 Lock 을 설정함으로써 버퍼블록 자체에 대한 직렬화 문제를 해결한다.
