조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, `옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택`한다.

# SGA vs PGA
공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다. 여러 프로세스가 공유할 수 있지만, `동시에 엑세스할 수는 없다.` 동시에 엑세스하려는 프로세스 간 엑세스를 직렬화하기 위한 Lock 메커니즘으로서 `래치가 존재`한다.

오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다. `각 오라클 서버 프로세스에 할당된 메모리 영역을 PGA`라고 부르며, 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다. 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 `Temp 테이블스페이스를 이용`한다.

PGA는 다른 프로세스와 공유하지 않는 `독립적인 메모리 공간이므로 래치 메커니즘이 불필요`하다. 따라서 같은 양의 데이터를 읽더라도 `SGA 버퍼캐시에서 읽을 때 보다 훨씬 빠르다.`

# 기본 메커니즘
소트 머지 조인은 이름이 의미하는 것처럼 아래 두 단계로 진행한다.
1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
2. 머지 단계: 정렬한 양쪽 집합을 서로 머지한다.

소트 머지 조인은 use_merge 힌트로 유도한다.
```oracle
select /*+ ordered use_merge(c)*/
    e.사원번호, e.사원명, e.입사일자
    , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'Z123'
and c.최종주문금액 >= 20000
```

위 SQL 수행 과정을 풀어서 설명하면 아래와 같다.

1. 아래 조건에 해당하는 사원 데이터를 읽어 조인컬럼인 사원번호 순으로 정렬한다. 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장한다. 정렬된 결과집합이 PGA에 담을 수 없을 정도로 크면, Temp 테이블스페이스에 저장한다.
```oracle
select 사원번호, 사원명, 입사일자
from 사원
where e.입사일자 >= '19960101'
and e.부서코드 = 'Z123'
order by 사원번호
```
2. 아래 조건에 해당하는 고객 데이터를 읽어 조인컬럼인 관리사원번호 순으로 정렬한다. 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장한다. 정렬된 결과집합이 PGA에 담을 수 없을 정도로 크면, Temp 테이블스페이스에 저장한다.
```oracle
select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
from 고객
where 최종주문금액 >= 20000
order by 관리사원번호
```
3. PGA에 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인한다. 조인하는 과정을 PL/SQL 코드로 표현하면 아래와 같다.
```
begin
    for outer in (select * from PGA에 정렬된_사원)
    loop -- outer 루프
        for inner in (select * from PGA에_정렬된_고객 where 관리사원번호 = outer.사원번호)
        loop -- inner 루프
            dbms_output.put_line( ... );
        end_loop;
    end_loop;
end;
```
여기서 주목할 점은 사원 데이터를 기준으로 고객 데이터를 `매번 Full Scan 하지 않는다`는 사실이다. 고객 데이터가 정렬돼 있으므로 조인에 실패하는 레코드를 만나는 순간 바로 멈출 수 있다.

`Sort Area에 저장한 데이터 자체가 인덱스 역할`을 하므로 소트 머지 조인은 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식이다.

# 소트 머지 조인이 빠른 이유
NL 조인의 치명적인 단점은 대량 데이터 조인할 때 성능이 매우 느리다는 것이다. 소트 머지 조인과 해시 조인이 개발된 이유다.

소트 머지 조인은 Sort Area에 미리 정렬해 둔 자료구조를 이용한다는 점만 다를 뿐 조인 프로세싱 자체는 NL 조인과 같다. 그렇다면 두 조인의 성능 차이는 어디서 나타나는 걸까? NL 조인은 단적으로 말해 '인덱스를 이용한 조인 방식'이다. 조인 과정에서 엑세스하는 `모든 블록을 랜덤 엑세스 방식으로 '건건이' DB 버퍼캐시를 경유해서 읽는다.` 즉, 인덱스든 테이블이든, 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거친다. `버퍼캐시에서 찾지 못한 블록은 '건건이' 디스크에서 읽어 들인다.` 이것이 대량 데이터 조인에 NL 조인이 불리한 이유다.

반면, 소트 머지 조인은 양쪽 테이블로부터 조인 대상 집합을 '일괄적으로' 읽어 PGA에 저장한 후 조인한다. PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 `데이터를 읽을 때 래치 획득 과정이 없다.` 소트 머지 조인이 대량 데이터 조인에 유리한 이유다.

조인 전에 양쪽 집합에 대한 소트 연산을 추가로 수행하기 때문에 NL 조인보다 더 느리지 않을까 싶지만, 이것이 오히려 `대량 데이터 조인에 유리하게 만든 핵심 요인`이다.

소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 사용하기도 한다. 이 과정에서 생기는 `버퍼캐시 탐색 비용과 랜덤 엑세스 부하는 소트 머지 조인도 피할 수 없다.`

# 소트 머지 조인의 주용도
소트 머지 조인은 소트 머지 조인보다 다방면에서 뛰어난 해시 조인의 등장으로 쓰임새가 예전만 못하다.

하지만 해시 조인은 조인 조건식이 등치(=) 조건이 아닐 때 사용할 수 없다는 단점이 있다. 그래서 소트 머지 조인은 아래와 같은 상황에 주로 사용된다.
- 조인 조건이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)

# 소트 머지 조인 특징 요약
소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다. 양쪽 집합을 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다. 따라서 `소트 부하만 감수한다면, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.`

NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다. 양쪽 집합을 개별적으로 읽고 나서 조인을 시작한다는 특징도 있다.

스캔 위주의 엑세스 방식을 사용한다는 점도 중요한 특징이다. 하지만 `인덱스를 이용할 수도 있고, 그때는 랜덤 엑세스가 발생`한다. 
