# 기본 메커니즘
```
< C, JAVA >
for(int i=0; i<100; i++){ -- outer loop
    for(in j=0; j<100; j++){ -- inner loop
        // Do anything.,,
    }
}

< PL/SQL >
for outer in 1..100 loop
    for inner in 1..100 loop
        dbms_output.put_line(outer || ' : ' || inner);
    end loop;
end loop;    
```
NL 조인은 위 `중첩 루프문과 같은 수행 구조를 사용`한다. 중첩 루프문을 사용하는 아래 PL/SQL 코드는 NL 조인이 어떤 순서로 데이터를 액세스하는지 잘 설명해 준다.

```
begin
    for outer in (select 사원번호, 사원명 from 사원 where 입사일자 >= ‘19960101’)
        loop -- outer 루프
            for inner in (select 고객명, 전화번호 from 고객 where 관리사원번호 = outer.사원번호)
            loop -- inner 루프
            dbms_output.put_line(outer.사원명 || ‘:’ || inner.고객명 || ‘:’ || inner.전화번호);
        end loop
    end loop
end
```

 일반적으로 `NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용`한다. `Outer 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다.` Table Full Scan 하더라도 그것은 한 번에 그치기 때문이다. 반면, `Inner 쪽 테이블은 인덱스를 사용해야 한다.` Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.

결국, NL 조인은 '인덱스를 이용한 조인 방식' 이라고 할 수 있다.

# NL 조인 실행계획 제어
아래는 NL 조인 실행계획이다. '위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인 한다'고 해석하면 된다.
```
SELECT STATEMENT Optimizer=ALL_ROWS
NESTED LOOPS
    TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
        INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
    TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
        INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

NL 조인을 제어할 때는 아래와 같이 use_nl 힌트를 사용한다.

```sql
select /*+ ordered use_nl(c) */
    e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= ‘19960101’
and c.관리사원번호 = e.사원번호
```
ordered 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. use_nl 힌트는 NL 방식으로 조인하라고 지시할 때 사용한다. 위에서는 ordered와 use_nl(c) 힌트를 같이 사용했으므로 사원 테이블(-> Driving 또는 Outer Table) 기준으로 고객 테이블(-> Inner 테이블)과 NL 방식으로 조인하라는 뜻이다.

세 개 이상 테이블을 조인할 때는 힌트를 아래처럼 사용한다.
```sql
select /*+ ordered use_nl(B) use_nl(C) use_hsah(D) */ * 
from A, B, C, D
where ....
```
해석해 보면, A -> B -> C -> D 순으로 조인하되, B와 조인할 때 그리고 이어서 C와 조인할 때는 NL 방식으로 조인하고, D와 조인할 때는 해시 방식으로 조인하라는 뜻이다.

ordered 대신 아래와 같이 leading 힌트를 사용할 수도 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고도 마음껏 순서를 제어할 수 있어 편리하다.
```sql
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hsah(B) */ *
from A, B, C, D
where ....
```

아래는 ordered나 leading 힌트를 기술하지 않았다. 네 개 테이블을 NL 방식으로 조인하되 순서는 옵티마이저가 스스로 정하도록 맡긴 것이다.
```sql
select /*+ use_nl(A, B, C, D) */ *
from A, B, C, D
where ....
```

# NL 조인 수행 과정 분석
NL 조인 수행 과정을 분석하기 위해 아래와 같이 조건절을 추가해보자. 힌트에 지시한 대로 수행할 때, 조건절 비교 순서는 어떻게 될까? 조건절 우측에 표시한 번호로 순서를 나열해 보자.
```sql
select /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사업번호 = e.사원번호     -- 1
and e.입사일자 >= ‘19960101’       -- 2
and e.부서코드 = ‘Z123’            -- 3
and c.최종주문금액 >= 20000         -- 4
```
인덱스 구성은 다음과 같다.
```
사원_PK : 사원번호
사원_X1 : 입사일자
고객_PK : 고객번호
고객_X1 : 관리사업번호
고객_X2 : 최종주문금액
```
두 테이블에 index 힌트를 명시했으므로 둘 다 인덱스를 이용해서 엑세스한다. 인덱스명은 명시하지 않았으므로 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.

힌트에 지시한 대로 SQL문을 수행했을 때 실행계획은 아래와 같다.
![](file:///Users/kinseonghyeon/Desktop/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-11-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.33.58.png)
SQL 조건절 우측에 표시한 번호로 조건절 비교 순서를 나열하면, 2 -> 3 -> 1 -> 4 순이다.

1. 조건절 번호 2 : 입사일자 >= ‘19960101’ 조건을 만족하는 레코드를 찾으려고 사원_X1 인덱스를 Range 스캔한다. (실행계획 ID=3)
2. 조건절 번호 3 : 사원_X1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 = ‘Z123’ 필터 조건을 만족하는지 확인한다. (실행계획 ID=2)
3. 조건절 번호 1 : 사원 테이블에서 읽은 사원번호 값으로 조인 조건(c.관리사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다. (실행계획 ID=5)
4. 조건절 번호 4 : 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다. (실행계획 ID=4)

여기서 기억할 것은, `각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드식 순차적으로 진행한다는 사실`이다.

# NL 조인 튜닝 포인트
첫 번째 튜닝 포인트는 사원_X1 인덱스를 읽고 나서 사원 테이블을 엑세스하는 부분이다. 여기서는 단일 컬럼 인덱스를 '>=' 조건으로 스캔했으므로 비효율 없이 6(5+1)건을 읽었고, 그만큼만 테이블 랜덤 액세스가 발했다. 만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고, 테이블에서 부서코드 = ‘Z123’ 조건에 의해 필터링되는 비율이 높다면 어떻게 해야 할까? 사원_X1 인덱스에 `부서코드 컬럼을 추가하는 방안을 고려`해야 한다.

두 번째 튜닝 포인트는 고객_X1 인덱스를 탐색하는 부분이다. 고객_X1 인덱스를 탐색하는 횟수, 즉 `조인 엑세스 횟수가 많을수록 성능이 느려진다.` 조인 엑세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다. 

세 번째 튜닝 포인트는 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분이다. 여기서도 최종주문금액 >= 20000 조건에 의해 필터링되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.

마지막으로, `맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다`는 사실도 기억하기 바란다. 사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스하는 횟수, 고객_X1 인덱스를 탐색하는 횟수, 고객 테이블로 랜덤 액세스하는 횟수가 전반적으로 많아진다.

### 올바른 조인 메소드 선택
`OLTP 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다.`

성능이 느리다면, NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 엑세스가 발생하는 지점을 우선 파악한다. 조인 순서를 변경하여 랜덤 엑세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.

여러 방안을 검토한 결과 `NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단될 때, 소트 머지 조인이나 해시 조인을 검토`한다.

# NL 조인 특징 요약
1. 랜덤 엑세스 위주의 조인 방식이다. 
- 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 엑세스 방식은 설령 `메모리 버퍼에서 빠르게 읽더라도 비효율이 존재`한다. 인덱스 구성이 아무리 완벽해도 `대량 데이터 조인할 때 NL 조인이 불리한 이유`다.
2. 한 레코드씩 순차적으로 진행한다. 
- 첫 번째 특징 때문에 대량 데이터 처리 시 매우 치명적인 한계를 드러내지만, 반대로 이 `두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답 속도를 낼 수 있다.` 부분범위 처리가 가능한 상황에서 그렇다.
3. 순차적으로 진행하므로 먼저 엑세스되는 테이블 처리 범위에 의해 전체 일량이 결정된다.
4. 다른 조인 방식과 비교할 때 인덱스 구성 전략이 특히 중요하다.
5. OLTP 시스템에 적합한 조인 방식이다.

# NL 조인 확장 메커니즘
버전이 올라가면서 오라클은 NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능을 도입했다. ‘테이블 Prefetch’는 인덱스를 이용해 `테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능`이다. ‘배치 I/O’는 `디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능`이다. 두 기능 모두, `읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안`되었다.

1. 전통적인 실행계획
```sql
NESTED LOOPS
	TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
		INDEX(RANGE SCAN) OF '사원_X1' (INDEX)
	TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
		INDEX(RANGE SCAN) OF '고객_X1' (INDEX)​
```

2. 테이블 Prefetch 실행계획
```sql
TABLE ACCESS BY INDEX ROWID OF 고객
	NESTED LOOPS
		TABLE ACCESS BY INDEX ROWID OF 사원
			INDEX RANGE SCAN OF 사원_X1
		INDEX RANGE SCAN OF 고객_X1​
```

3. 배치 I/O 실행계획
```sql
NESTED LOOPS
	NESTED LOOPS
		TABLE ACCESS BY INDEX ROWID OF 사원
			INDEX RANGE SCAN OF 사원_X1
		INDEX RANGE SCAN OF 고객_X1
	TABLE ACCESS BY INDEX ROWID OF 고객​
```
