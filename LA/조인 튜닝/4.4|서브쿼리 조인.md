# 서브쿼리 변환이 필요한 이유
하나의 결과집합을 얻기 위해 SQL을 여러 가지 다른 형태로 표현할 수 있고, 어떤 것을 선택하느냐에 따라 성능도 다를 수 있다. 그래서 최근 옵티마이저는 비용을 평가하고 실행계획을 생성하기에 앞서 `사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환하는 작업, 즉 쿼리 변환부터 진행`한다.

쿼리 변환은 옵티마이저가 SQL을 분석해 `의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것`을 말한다.

서브쿼리는 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록을 말한다. 쿼리에 내장된 또 다른 쿼리다. 서브쿼리를 DBMS마다 다르게 분류하는데, 오라클은 아래와 같이 분류한다.
```oracle
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
     , (select 고객분류명 from 고객분류 where 고객분류코드 = c.고객분류코드) -- 스칼라 서브쿼리
  from 고객 c
     , (select 고객번호, avg(거래금액) 평균거래 -- 인라인 뷰 
             , min(거래금액) 최소금액, max(거래금액) 최대거래
        from 거래
        where 거래일시 >= trunc(sysdate, ‘MM’)
         grou by 고객번호) t
 where c.가입일시 >= trunc(add_months(sysdate, -1), ‘mm’)
   and t.고객번호 = c.고객번호
   and exists (select ‘X’ -- 중첩된 서브쿼리
                 from 고객변경이력 h
                where h.고객번호 = c.고객번호
                  and h.변경사유코드 = ‘ZCH’
                  and c.최종변경일시 between h.시작일시 and h.종료일시) 
```
1. 인라인 뷰: FROM 절에 사용한 서브쿼리를 말한다.
2. 중첩된 서브쿼리: 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리를 말한다. 특히, 서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 '상관관계 있는 서브쿼리'라고 부른다.
3. 스칼라 서브쿼리: 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리다. 주로 SELECT-LIST에서 사용하지만 몇 가지 예외사항을 제외하면 컬럼이 올 수 있는 대부분 위치에 사용할 수 있다.
 
이들 서브쿼리를 참조하는 메인 쿼리도 하나의 쿼리 블록이며, 옵티마이저는 `쿼리 블록 단위로 최적화를 수행`한다.

# 서브쿼리와 조인
메인쿼리와 서브쿼리 간에는 부모와 자식이라는 종속적이고 계층적인 관계가 존재한다. `서브쿼리는 메인쿼리에 종속되므로 단독으로 실행할 수 없다.` 메인쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 한다.

### 필터 오퍼레이션
아래는 서브쿼리를 필터 방식으로 처리할 때의 실행계획이다. no_unnest 힌트를 사용하면 서브쿼리를 풀어내지 말고 필터 방식으로 처리하도록 유도한다.
```oracle
select c.고객번호, c.고객명
from 고객 c
where c.가입일시 >= TRUNC(add_months(sysdate, -1), ‘mm’)
  and exists (SELECT /*+ no_unnest */ 'x'
              from 거래
              where 고객번호 = c.고객번호
                and 거래일시 >= trunc(sysdate, ‘mm’))

Excution  Plan
-------------------------------------------------------------------------------------
0        SELECT STATMENT Optimizer=ALL_ROWS (Cost=289 Card=1 Bytes=39)
1   0    FILTER
2   1    TABLE ACCESS (BY INDEX ROWID) OF ‘고객’ (TABLE) (Cost=4 Card=190 ...)
3   2        INDEX (RANGE SCAN) OF ‘고객_X01’ (INDEX) (Cost=2 Card=190.)
4   1    INDEX (RANGE SCAN) OF ‘고객_X01’ (INDEX) (Cost=3 Card=4K Bytes=92k)
```
필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같다. 따라서 위 실행계획에서 'FILTER'를 'NESTED LOOPS'로 치환하고 처리 루틴을 해석하면 된다. `NL 조인처럼 부분범위 처리도 가능`하다.

차이가 있다면 첫째, 필터는 `메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 계속 처리`한다는 점이다. 이렇게 처리해야 메인쿼리 결과집합이 서브쿼리 집합 수준으로 확장되는 현상을 막을 수 있다.

NL 조인과 다른 두 번째 차이점은, 필터는 캐싱기능을 갖는다는 점이다. 이는 필터처리한 결과, 즉 `서브쿼리 입력 값에 따른 반환 값을 캐싱하는 기능`이다. 이 기능이 작동하므로 서브쿼리를 수행하기 전에 항상 캐시부터 확인한다.

마지막으로, 필터 서브쿼리는 일반 NL 조인과 달리 `메인쿼리에 종속되므로 조인 순서가 고정`된다. 항상 메인 쿼리가 드라이빙 집합이다.

### 서브쿼리 Unnesting
아래는 서브쿼리를 Unnesting 할 때의 실행계획이다. 그냥 두어도 옵티마이저가 대개 Unnesting을 선택한다.
```oracle
select c.고객번호, c.고객명
from 고객 c
where c.가입일시 >= TRUNC(add_months(sysdate, -1), ‘mm’)
  and exists (SELECT /*+ unnest nl_sj */ 'x'
              from 거래
              where 고객번호 = c.고객번호
                and 거래일시 >= trunc(sysdate, ‘mm’))

Excution  Plan
-------------------------------------------------------------------------------------
0        SELECT STATMENT Optimizer=ALL_ROWS (Cost=384 Card=190 Bytes=1K)
1   0    NESTED LOOPS (SEMI) (Cost=384 Card=190 Bytes=11K)
2   1    TABLE ACCESS (BY INDEX ROWID) OF ‘고객’ (TABLE) (Cost=4 Card=190 ...)
3   2        INDEX (RANGE SCAN) OF ‘고객_X01’ (INDEX) (Cost=2 Card=190)
4   1    INDEX (RANGE SCAN) OF ‘고객_X01’ (INDEX) (INDEX) (Cost=2 Card=427K Bytes=9M)
```
서브쿼리 Unnesting은 메인과 `서브쿼리 간의 계층구조를 풀어 서로 같은 레벨로 만들어 준다는 의미`에서 '서브쿼리 Flattening'이라고 부르기도 한다.

서브쿼리를 Unnesting하는 이유는 무엇일까?

서브쿼리를 Unnesting 해서 메인쿼리와 같은 레벨로 만들면 `다양한 조인 메소드(hash, nl...)를 선택할 수 있고, 조인 순서도 마음껏 정할 수 있다.` 옵티마이저는 많은 조인 테크닉을 가지기 때문에 `조인 형태로 변환했을 때 필터 오퍼레이션보다 더 좋은 실행경로를 찾을 가능성이 높아진다.`

### ROWNUM - 잘 쓰면 약, 잘못 쓰면 독
ROWNUM을 잘 사용하면 쿼리 성능을 높이는 데 아주 효과적이다. 반면, 잘못 사용하면 쿼리 성능을 떨어뜨리기도 한다. 병렬 쿼리나 서브쿼리에 rownum을 사용하는 경우가 대표적이다.

Exists는 매칭되는 데이터 존재 여부를 확인하는 연산자이므로 조건을 만족하는 레코드를 만나는 순간 멈추는 기능을 이미 갖고 있다. 아래와 같이 Exists 서브쿼리에 rownum 조건까지 사용하면 의미의 중복이다. 이러한 중복은 성능에 문제를 일으킬 수 있다.
```oracle
select 글번호, 제목, 작성자, 등록일시
from 게시판 b
where 게시판구분 = '공지'
and 등록일시 >= trunc(sysdate-1)
and exists (select 'x'
            from 수신대상자
            where 글번호 = b.글번호
            and 수신자 = :memb_no
            and rownum <= 1)
```
서브쿼리를 Unnesting 하면 필터 오퍼레이션보다 더 좋은 실행경로를 찾을 가능성이 커진다. 그런데 `서브쿼리에 rownum을 쓰면 이 중요한 옵티마이징 기능을 사용하지 못하게 막는 부작용이 발생`한다. 

rownum은 이처럼 옵티마이저를 꼼짝 못 하게 하는 강력한 독이 될 수 있으므로 서브쿼리에 함부로 쓰지 않도록 주의해야한다.

### 서브쿼리 Pushing
앞에서 설명한 것처럼 Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대개 실행계획 상에서 맨 마지막 단계에 처리된다. 

Pushing 서브쿼리는 `서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능`이며, push_subq/no_push_subq 힌트로 제어한다.

이 기능은 `Unnesting 되지 않은 서브쿼리에만 작동`한다. Unnesting 되는 순간 push_subq 힌트는 무용지물이다. 따라서 `push_subq 힌트는 항상 no_unnest 힌트와 같이 기술하는 것이 올바른 사용법`이다. 반대로 서브쿼리 필터링을 가능한 한 나중에 처리하게 하려면 no_unnest 와 no_push_subq를 같이 사용하면 된다.

# 뷰(View)와 조인
최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.

머징을 통해 인라인 뷰에서 메인 쿼리에 접근할 수 있다. 뷰 머징을 할 때는 merge, 방지하고자 할 때는 no_merge 힌트를 사용한다.    

### 조인 조건 Pushdown
11g 이후로 '조인 조건 Pushdown'이라는 쿼리 변환 기능이 작동한다. 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능이며 부분범위 처리가 가능하다.

이 방식을 사용하면 '건건이' 데이터만 읽어서 조인하고 Group By를 수행할 수 있다. 이 기능을 제어하는 힌트는 push_pred이다. 옵티마이저가 뷰를 머징하면 힌트가 작동하지 않으니 no_merge 힌트를 함께 사용하는 습관이 필요하다. 

# 스칼라 서브쿼리 조인
### 1. 스칼라 서브쿼리의 특징
스칼라 서브쿼리는 `메인쿼리 레코드마다 정확히 하나의 값만 반환`한다. 함수처럼 재귀적으로 실행하는 구조가 아니며 컨텍스트 스위칭 없이 `메인쿼리와 서브쿼리를 한 몸체처럼 실행`한다.
```oracle
select empno, ename, sal, hiredate
    ,(select d.dname from dept d where d.deptno = e.deptno) as dname
from emp e 
where sal >= 2000
```
스칼라 서브쿼리를 사용한 쿼리문은 `Outer 조인문처럼 NL 조인 방식으로 실행`된다.

### 2. 스칼라 서브쿼리 캐싱 효과
스칼라 서브쿼리로 조인하면 오라클은 `조인 횟수를 최소화하려고 입력 값과 출력 값을 내부 캐시에 저장`해둔다. 캐시에서 찾지 못할 때만 조인을 수행하며, 결과는 버리지 않고 캐시에 저장해 둔다.

스칼라 서브쿼리 캐싱은 `필터 서브쿼리 캐싱과 같은 기능`이다. 이런 캐싱 메커니즘은 조인 성능을 높이는 데 큰 도움이 된다. 메인쿼리 집합이 아무리 커도 `조인할 데이터를 대부분 캐시에서 찾는다면, 조인 수행횟수를 최소화할 수 있기 때문`이다.

캐싱은 쿼리 단위로 이루어진다. 쿼리를 시작할 때 PGA 메모리에 공간을 할당하고, 쿼리를 수행하면서 공간을 채워나가며, 쿼리를 마치는 순간 공간을 반환한다.

함수는 재귀적 특징 때문에 무겁다는 단점이 존재하는데 스칼라 서브쿼리를 덧씌워서 캐싱 효과를 적용시키면 더 가볍게 사용할 수 있다.
```oracle
select empno, ename, (select GET_DNAME(e.deptno) from dual) dname from emp e;
```

### 3. 스칼라 서브쿼리 캐싱 부작용
모든 캐시가 다 그렇듯, 캐시 공간은 늘 부족하다. 스칼라 서브쿼리에 사용하는 캐시도 매우 작은 메모리 공간이다.

결론적으로, 스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 적을 때 효과가 있다. 반대의 경우라면 캐시를 매번 확인하는 비용 때문에 오히려 성능이 나빠지고 CPU 사용율만 높게 만든다. 메모리도 더 사용한다.

스칼라 서브쿼리 캐싱이 성능에 도움을 주지 못하는 경우가 또 있는데, 메인 쿼리 집합이 매우 작은 경우다. 메인쿼리 집합이 작으면 캐시 재사용성도 낮다.

### 4. 두 개 이상의 값 반환
스칼라 서브쿼리는 두 개 이상의 값을 반환할 수 없다는 제약이 있다.

이러한 제약을 우회하기 위해 다음과 같은 방법을 사용해 왔다.
```oracle
select 고객번호, 고객명
     , to_number(substr(거래금액, 1, 10)) 평균거래금액
     , to_number(substr(거래금액, 11, 10)) 최소거래금액
     , to_number(substr(거래금액, 21)) 최대거래금액
  from (select c.고객번호, c.고객명
             , (select lpad(avg(거래금액), 10 || lpad(min(거래금액), 10 || lpad(max(거래금액), 10
                  from 거래
                 where 거래일시 >= trunc(sysdate, ‘mm’
                   and 고객번호 = c.고객번호) 거래금액
        from 고객 c
        where c.가입일시 >= trunc(add_months(sysdate, -1), ‘mm’)
    )
```
구하는 값들을 모두 결합하고, 바깥쪽 엑세스 쿼리에서 substr함수로 다시 분리하는 방식이다.

두 개 이상의 값을 반환하고 싶을 때, 이런저런 고민 없이 인라인 뷰를 사용하면 편하긴 하다.

```oracle
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
from 고객 c
    ,(select 고객번호, avg(거래금액) 평균거래, min(거래금액) 최소거래, max(거래금액) 최대거래
      from 거래
      where 거래일시 >= trunc(sysdate, 'mm')
      group by 고객번호) t
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
and t.고객번호(+) = c.고객번호
```

뷰를 머징하지 않고 사용할 경우 group by 때문에 부분범위 처리가 되지 않는 문제가 있다. 다행히 11g 이후로는 Pushdown 기능이 잘 작동하기 때문에 인라인 뷰를 마음 편히 사용할 수 있게 되었다.

### 5. 스칼라 서브쿼리 Unnesting 
`스칼라 서브쿼리도 NL 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 I/O 부담`이 있다. 그래서 다른 조인 방식을 선택하기 위해 스칼라 서브쿼리를 일반 조인문으로 변환하고 싶을 때가 있다. 특히, 병렬 쿼리에선 될 수 있으면 스칼라 서브쿼리를 사용하지 않아야 한다. 대량 `데이터를 처리하는 병렬 쿼리는 해시 조인으로 처리해야 효과적`이기 때문이다.

`오라클 12c부터 스칼라 서브쿼리도 Unnesting이 가능`해졌다. 옵티마이저가 사용자 대신 자동으로 쿼리를 변환해 주는 것이다.

_optimizer_unnest_scalar_sq 파라미터를 true로 설정하면, 스칼라 서브쿼리를 Unnesting 할지 여부를 옵티마이저가 결정한다. false로 설정하면 옵티마이저가 이 기능을 사용하지 않지만, 사용자가 unnest 힌트로 유도할 수 있다.
