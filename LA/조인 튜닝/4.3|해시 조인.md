# 기본 메커니즘
해시 조인도 소트 머지 조인처럼 두 단계로 진행된다.
1. Build 단계: 작은 쪽 테이블을 읽어 해시 테이블을 생성한다.
2. Probe 단계: 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인한다.

해시 조인은 use_hash 힌트로 유도한다.

```oracle
SELECT /*+ ordered use_hash(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
  FROM 사원 e, 고객 c
 WHERE c.관리사원번호 = e.사원번호
   AND e.입사일자 >= ‘19960101’
   AND e.부서코드 = ‘Z123’
   AND c.최종주문금액 >= 2000
```

1. Build 단계: 아래 조건에 해당하는 사원 데이터를 읽어 해시 테이블을 생성한다. 이때, 조인컬럼인 사원번호를 해시 테이블 키 값으로 사용한다. 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다. 해시 테이블이 너무 커 PGA에 담을 수 없으면, Temp 테이블스페이스에 젖아한다.

```oracle
select 사원번호, 사원명, 입사일자
from 사원
where 입사일자 >= '19960101'
and 부서코드 = 'Z123'
```

2. Probe 단계: 아래 조건에 해당하는 고객 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색한다. 같은 키 값을 찾으면 조인에 성공한 것이고, 못 찾으면 실패한 것이다.
```oracle
select 고객번호, 고객명, 전화번호, 최종주문금액
from 고객
where 최종주문금액 >= 20000
```

Probe 단계에서 조인하는 과정을 PL/SQL 코드로 표현하면 아래와 같다.
```
begin
    for outer in (select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
                    from 고객
                   where 최종주문금액 >= 20000)
    loop -- outer 루프
        for inner in (select 사원번호, 사원명, 입사일자
                          from PGA에_생성한_사원_해시맵 
                       where 사원번호 = outer.관리사원번호)
        loop -- inner 루프
            dbms_output.put_line( ... );
        end loop;
    end loop;
end;
```
*실제 조인을 수행하는 `Probe 단계는 NL 조인과 다르지 않다`는 사실을 확인할 수 있다.*

# 해시 조인이 빠른 이유
Hash Area에 생성한 해시 테이블을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 같다. 그런데도 해시 조인이 인덱스 기반의 NL 조인보다 빠른 결정적인 이유는, 소트 머지 조인이 빠른 이유와 같다. 즉, `해시 테이블을 PGA 영역에 할당하기 때문`이다. 덕분에 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.

해시 조인도 Build Input과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 사용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 엑세스 부하는 `해시 조인도 피할 수 없다.`

해시 조인과 소트 머지 조인 모두 조인 오퍼레이션을 PGA 영역에서 처리한다는 공통점을 갖는다. 그런데 대량 데이터를 조인할 때 일반적으로 해시 조인이 빠른 이유는 무엇일까?

소트 머지 조인은 사전에 '양쪽' 집합을 모두 정렬해서 PGA에 담는 작업을 진행한다. `PGA는 그리 큰 영역이 아니기 때문`에 두 집합 중 어느 하나가 중대형 이상이면, Temp 테이블스페이스에 저장하는 작업을 반드시 수반한다.

정리하면 해시 조인은, NL 조인처럼 조인 과정에서 발생하는 `랜덤 엑세스 부하가 없고`, 소트 머지 조인처럼 양쪽 집합을 `미리 정렬하는 부하도 없다.` 해시 테이블을 생성하는 비용이 수반되지만, `둘 중 작은 집합을 Build Input으로 선택하므로 대개는 부담이 크지 않다.` Build Input이 PGA 메모리에 담길 때, 즉 인메모리 해시 조인일 때 가장 효과적인 이유가 바로 여기에 있다.

### 해시 테이블에 담기는 정보
많은 사람들이 해시 테이블에 조인 키값만 저장한다고 알고 있다. 만약 해시 테이블을 그렇게 생성한다면, 래치 획득 과정 없이 PGA에서 조인한다는 해시 조인의 장점이 사라진다. 조인에 성공한 정보를 읽으려면 ROWID로 다시 테이블 블록을 엑세스해야 하기 때문이다.

인덱스 ROWID로 테이블을 랜덤 엑세스하는 NL 조인의 단점 때문에 소트 머지 조인과 해시 조인이 탄생했다는 사실을 기억해야한다. 해시 테이블에는 `조인 키값뿐만 아니라 SQL에 사용한 컬럼을 모두 저장`한다.

# 대용량 Build Input 처리
두 테이블 모두 대용량 테이블이어서 인메모리 해시 조인이 불가능한 상황이 존재한다. 이럴 때 DBMS는 어떤 방식으로 해시 조인을 처리할까?? 복잡할 것 같지만, 의외로 간단하다. 아래 두 단계로 나눠서 진행된다. 분할-정복 방식이다.

1. 파티션 단계
- 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝한다. 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 짝을 생성하는 단계이다. 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.

2. 조인 단계
- 파티션 단계를 완료하면 각 파티션 짝에 대해 하나씩 조인을 수행한다. 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다. 즉, 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝별로 작은 쪽을 Build Input으로 선택하고 해시 테이블을 생성한다. 
- 해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색한다. 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복한다.

# 해시 조인 실행계획 제어
해시 조인 실행계획을 제어할 때 use_hash 힌트를 사용한다.
```oracle
select /*+ use_hash(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= ‘19960101’
and e.부서코드 = ‘Z123’
and c.최종주문금액 >= 2000
```
여기서는 use_hash힌트만 사용했으므로 Build Input을 옵티마이저가 선택하는데, `일반적으로 둘 중 카디널리티가 작은 테이블을 선택`한다.

Build Input을 사용자가 직접 선택하고 싶다면 어떻게 할까? 조인 대상 테이블이 두 개뿐이라면 leading, ordered 힌트를 사용하면 된다. 오라클은 기본적으로 `이들 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 Build Input으로 선택`한다.

```oracle
select /*+ leading(e) use_hash(c) */ -- 또는 ordred use_hash(c)
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= ‘19960101’
and e.부서코드 = ‘Z123’
and c.최종주문금액 >= 2000
```

아래와 같이 swap_join_inputs 힌트로 Build Input을 명시적으로 선택할 수도 있다.
```oracle
select /*+ leading(e) use_hash(c) swap_join_inputs(c) */ -- 또는 ordred use_hash(c)
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= ‘19960101’
and e.부서코드 = ‘Z123’
and c.최종주문금액 >= 2000
```

### 세 개 이상 테이블 해시 조인
- 조인하는 테이블이 몇 개든, 조인 연결고리를 따라 순방향 또는 역방향으로 leading 힌트에 기술한 후, `Build Input으로 선택하고 싶은 테이블을 swap_join_inputs 힌트에 기술`해주면 된다.
- 조인한 결과집합을 swap_join_inputs 힌트에 지정하기 어렵다면, no_swap_join_inputs 힌트를 사용하면 된다. 조인한 결과 집합을 Build Input으로 선택해 주는 것이 아니라 `반대쪽 테이블을 Probe Input으로 선택해주는 방법`이다.   

# 조인 메서드 선택 기준
1. 소량 데이터 조인할 때 => NL 조인
2. 대량 데이터 조인할 때 => 해시 조인
3. 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때 => 소트 머지 조인

여기서 소량과 대량의 기준은 단순히 데이터량의 많고 적음이 아니다. `NL 조인 기준으로 최적화를 진행했는데도, 랜덤 엑세스가 많아 만족할만한 성능이 나오지 않는다면, 대량 데이터 조인에 해당`한다.

수행빈도가 매우 높은 쿼리에 대해선 아래와 같은 기준도 제시하고 있다.
1. (최적화된) NL 조인과 해시 조인 성능이 같으면, NL 조인
2. 해시 조인이 약간 더 빨라도 NL 조인
3. NL 조인보다 해시 조인이 매우 빠른 경우, 해시 조인

SQL 최적화할 때 옵티마이저가 수행빈도까지 고려하지 않으므로 이는 매우 중요한 선택 기준이다.

그럼 왜, 조인 메소드를 선택할 때 NL 조인을 가장 먼저 고려해야 할까?

NL 조인에 사용하는 `인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조`다. 반면, `해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조`다. 같은 쿼리를 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개가 만들어진다. 따라서 `수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리한다면 CPU와 메모리 사용률이 크게 증가`한다.

결론적으로 해시 조인은 아래 세 가지 조건을 만족하는 SQL문에 주로 사용한다.
1. 수행 빈도가 낮고
2. 쿼리 수행 시간이 오래 걸리는
3. 대량 데이터 조인할 때
