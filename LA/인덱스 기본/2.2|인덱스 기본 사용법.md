# 인덱스를 사용한다는 것
인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다. '인덱스를 정상적으로 사용한다' 는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉, `Index Range Scan 을 의미`한다.

인덱스 컬럼을 가공하더라도 인덱스를 사용할 수 있다. 하지만 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다. `즉, Index Full Scan 방식으로 작동`한다.

# 인덱스를 Range Scan 할 수 없는 이유
인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 이유는 `인덱스 스캔 시작점을 찾을 수 없기 때문`이다.

데이터베이스에서 아래와 같은 조건절을 처리할 때 인덱스를 정상적으로 사용할 수 없는 문제에 직면한다.
1. 조건절에서 인덱스 컬럼을 가공하는 경우
```sql
where substr(생년월일, 5, 2) = '05';
where nvl(주문수량,0) < 100;
```
    
2. like 키워드로 중간값을 검색하는 경우
```sql
where 업체명 like '%대한%';
```
    
3. OR 조건으로 검색하는 경우
```sql
where (전화번호 =: tel_no OR 고객명 =: cust_nm);
```
- OR Expansion
    ```sql
    다음과 같이 쿼리를 작성하면 Index Rage Scan 이 가능하다.
  
    select *
    from 고객
    where 고객명 =: cust_nm -- 고객명이 선두 컬럼인 인덱스 Range Scan
    union all
    select *
    from 고객
    where 고객명 =: tel_no -- 전화번호가 선두 컬럼인 인덱스 Range Scan
    and (고객명<> : cust_nm or 고객명 is null)
    
    OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데 이를 'OR Expansion' 이라고 한다. /*+use_concat*/ 힌트를 이용해서 OR expansion 을 유도하는 것도 가능하다. 
    ```

4. IN 조건으로 검색하는 경우
```sql
where 전화번호 in (:tel_no1, :tel_no2);
    
IN 조건은 OR 조건과 같다. 다행히 UNION ALL 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 Range Scan 이 가능하다.

select *
from 고객
where 전화번호 = :tel_no1
union all 
select *
from 고객
where 전화번호 = :tel_no2;

그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan 을 반복하는 것이다. 이를 통해 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다. 
```    

# 더 중요한 인덱스 사용 조건
조건절에서 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 하지만 인덱스를 정상적으로 사용하는 데 있어 더 중요한 선행조건이 있다.

인덱스를 정상적으로 사용하기 위한 가장 첫 번째 조건은 `인덱스 선두 컬럼이 조건절에 있어야 한다`는 사실이다. 즉 `인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan 은 무조건 가능`하다. 

하지만 여기서 문제는, `인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니다.`

### 인덱스 잘 타니까 튜닝 끝?
> 💡 인덱스 Range Scan 을 하더라도 스캔 범위(인덱스 리프 블록에서 스캔하는 양)를 효율적으로 줄일 수 없다면 인덱스를 잘 탄다고 말할 수 없다. 

# 인덱스를 이용한 소트 연산 생략
인덱스는 항상 정렬 상태를 유지한다. 항상 정렬되어 있기 때문에 Range Scan 이 가능하고, `소트 연산 생략 효과도 부수적으로 얻을 수 있다.`

옵티마이저는 이런 속성을 활용하여 SQL 에 ORDER BY 가 있어도 정렬 연산을 따로 수행하지 않는다. `PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.`

오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을, 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색 후 좌측으로 수평적 탐색을 한다.

# ORDER BY 절에서 컬럼 가공
인덱스 컬럼을 가공하여 조건절에 사용하는 경우 인덱스를 정상적으로 사용할 수 없다. 그런데 `조건절이 아닌 ORDER BY 또는 SELECT-LISt 에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 존재`한다.
```sql
SELECT *
FROM (
    SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 =: dt
    AND A.주문번호 > NVL(:next_ord_no, 0)
    ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```
해당 SQL 의 실행 계획을 확인하면 SORT ORDER BY 연산이 추가되어 있다. 이유는 무엇일까?? `ORDER BY 절에 기술한 '주문번호' 는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호를 가리키기 때문이다.`

# SELECT-LIST 절에서 컬럼 가공
인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성하면 변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 하지 않는다. 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최소값이기 때문이다. 반대로 가장 오른쪽 지점으로 내려가서 첫 번째 읽는 레코드가 최대값이 된다. 

# 자동 형변환
각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다. 그럴 때 `타입 체크를 엄격하게 함으로써 컴파일 시점에 에러를 낸다.` (DBMS 마다 상이하며 오라클은 에러를 발생시키는 쪽에 속한다)
```sql
select * from 고객
where 가입일자 = '01-JAN-2018';

오라클은 날짜형과 문자형이 만나면 날짜형이 이기기 때문에 좌변 컬럼 기준으로 우변을 변환한다. 
```
이렇게 하더라도 사용하는데 있어 문제가 전혀 없다. 하지만 NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과집합이 틀려질 수 있다. 그렇기 때문에 `포맷을 정확히 지정해 주는 코딩 습관이 필요하다.`
```sql
select * from 고객
where 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY');
```

### 자동 형변환 주의
자동 형변환이 작동하면 편리하다고 생각할 수 있지만, 이 기능 때문에 `성능과 애플리케이션 품질에 종종 문제가 발생`한다. 

'형변환을 함수를 생략함으로써 연산횟수가 줄어 성능이 더 좋아진다' 라고 생각할 수 있지만 SQL 성능은 결국 블록 I/O 를 줄일 수 있느냐 없느냐에서 결정된다. 그리고 `형변환 함수를 생략하더라도 옵티마이저가 자동으로 생성`한다.

그렇기 때문에 해당 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환을 해주는 것이 좋다.
