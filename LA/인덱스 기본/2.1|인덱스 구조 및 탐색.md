# 인덱스
인덱스는 `추가적인 쓰기 작업과 저장공간을 사용하여 데이터 조회 속도를 향상시키기 위한 자료구조`를 의미한다.

인덱스는 항상 정렬된 상태가 유지되어야 한다. 이와 같은 특징 때문에 수정, 삭제 와 같은 연산이 일어날 때 마다 정렬을 해줘야 하는 단점이 존재한다.  

# 미리 보는 인덱스 튜닝
### 데이터를 찾는 두 가지 방법
예를 들어 어떤 학교를 방문하여 홍길동이라는 학생을 찾는 방법은 두 가지가 있다. 첫 번째 방법은 각 학년마다 존재하는 모든 교실을 돌아다니며 찾는 것, 두 번째 방법은 교무실에 들어가 학생명부로 홍길동이라는 학생이 소속된 교실을 찾아가는 것이다.

둘 중 어느 쪽이 빠를까?? `만약 홍길동이라는 이름을 가진 학생의 수가 많다면 첫 번째 방법이 빠를 것이고, 아니라면 두 번째 방법이 빠를 것이다.`

### 인덱스 튜닝의 두 가지 핵심요소
인덱스는 테이블에서 소량 데이터를 검색할 때 사용한다. 인덱스를 튜닝하는 방법에는 여러가지가 존재하지만 핵심요소는 크게 두 가지로 나뉜다. 첫 번째는 `인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것`, 두 번째는 `랜덤 엑세스를 최소화화는 것`이다. 

인덱스를 튜닝하는데 있어서 두 방법 모두 중요하지만 랜덤 엑세스를 최소화하는 것이 성능을 개선하는데 더 큰 영향을 끼친다.

> 💡 SQL 튜닝은 랜덤 I/O 와의 전쟁이다.

### SQL 튜닝은 랜덤 I/O 와의 전쟁
데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O 가 많이 발생할 때 느리다. `인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O 가 특히 중요하다.`
- [OLTP](https://www.oracle.com/kr/database/what-is-oltp/)

### 인덱스 구조
인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 엑세스하기 위해 사용하는 오브젝트다.

데이터베이스에서 인덱스 없이 데이터를 검색하려면 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔이 가능하다. `범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문`이다.

루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. 이를 'LMC' 라고 하며 'Leftmost Child' 의 줄임말이다. `LMC 는 자식 노드 중 가장 왼쪽 끝에 위치한 블록`을 가리킨다. LMC 가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 ROWID 를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다. `인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID 를 얻기 위해서다.` ROWID 는 DBA 와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.
- ROWID = DBA + 로우 번호
- DBA = 데이터 파일 번호 + 블록 번호
- 블록 번호: 데이터파일 내에서 부여한 상대적 순번
- 로우 번호: 블록 내 순번

# 인덱스 수직적 탐색
정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, `인덱스 스캔 시작지점을 찾는 과정`이다.

인덱스 수직적 탐색은 루트 블록에서부터 시작한다. `수직적 탐색이 가능한 이유는 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖기 때문이다.`

수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다. 이렇게 하위 블록으로 이동하는 이유는 수직적 탐색 과정이 `조건에 맞는 레코드를 찾는 과정이 아닌 조건을 만족하는 첫 번째 레코드를 찾는 과정` 이기 때문이다.

# 인덱스 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. `본격적으로 데이터를 탐색하는 과정`이다. `인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 가진 양방향 연결 리스트 구조`이다. 이것이 좌에서 우로, 우에서 좌로 수평적 탐색이 가능한 이유이다.

# 결합 인덱스 구조와 탐색
두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. 

여기서 주목할 것은, `인덱스를 'A, B' 로 구성하든, 'B, A' 로 구성하든 읽는 인덱스 블록 개수가 똑같다`는 사실이다. 인덱스 선두 컬럼을 모두 "=" 조건으로 검색하면 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.

인터넷에서 다음과 같은 글을 찾아 볼 수 있다.
```sql
select 이름, 성별
from 사원
where 성별 = ‘여자’
and 이름 = ‘유관순’

1. 인덱스를 [성별 + 이름] 순으로 구성한 경우
총 사원 50명 중에서 성별 = ‘여자’인 레코드 25건을 찾고, 거기서 이름을 검사해 최종적으로 2명 출력 -> 25번의 검사

2. 인덱스를 [이름 + 성별] 순으로 구성한 경우
총 사원 50명 중에서 이름 = ‘유관순＇인 레코드 2건을 찾고, 거기서 성별을 검사해 최종적으로 2명 출력 -> 2번의 검사
```
해당 내용에서는 선택도가 낮은 '이름' 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 검사 횟수를 줄일 수 있어 성능에 유리하다고 한다. 하지만 이는 잘못된 내용이다. `DBMS 가 사용하는 B*Tree 인덱스는 엑셀처럼 평면 구조가 아니다. 때문에 어느 컬럼을 앞에 두든 일량에는 차이가 없다.` 
