## 소트 수행 과정
소트는 기본적으로 PGA에 할당한 Sort Area에서 이루어진다. 메모리 공간인 Sort Area가 다 차면, 디스크 Temp 테이블스페이스를 활용한다. Sort Area에서 작업을 완료할 수 있는지에 따라 소트를 두 가지 유형으로 나눈다.

- 메모리 소트: 메모리 내에서 전체 정렬 작업을 완료하는 것. 'Internal Sort'라고도 한다.
- 디스크 소트: Sort Area내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우. 'External Sort'라고도 한다.

### 디스크 소트 과정
일차적으로 Sort Area에서 정렬을 시도한다. Sort Area 내에서 데이터 정렬을 마무리하는 것이 최적이지만, 양이 많을 때는 `정렬된 중간 집합을 Temp 테이블스페이스에 임시 세그먼트를 만들어 저장`한다. Sort Area가 찰 때마다 Temp 영역에 저장해 둔 중간 단계의 집합을 'Sort Run'이라고 부른다.

정렬된 최종 결과집합을 얻으려면 이를 다시 Merge 해야 한다. 각 Sort Run 내에서는 이미 정렬된 상태이므로 Merge 과정은 어렵지 않다. 오름차순 정렬이라면 각각에서 가장 작은 값부터 PGA로 읽어 들이다가 `PGA가 찰 때마다 쿼리 수행 다음 단계로 전달하거나 클라이언트에게 전송`하면 된다.

소트 연산은 메모리 집약적일 뿐만 아니라 CPU 집약적이기도 하다. 처리할 데이터량이 많을 때는 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소다.

많은 서버 리소스를 사용하고 디스크 I/O가 발생하는 것도 문제지만, `부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인`이 되기도 한다. 그렇기 때문에 될 수 있으면 소트가 발생하지 않도록 SQL을 작성해야 하고, 소트가 불가피하다면 메모리 내에서 수행을 완료할 수 있도록 해야 한다.

## 소트 오퍼레이션
### Sort Aggregate
Sort Aggregate는 전체 로우를 대상으로 집계를 수행할 때 나타난다. 'Sort'라는 표현을 사용하지만, 실제로 데이터를 정렬하진 않는다. Sort Area를 사용한다는 의미로 이해하면 된다.

### Sort Order By
Sort Order By는 정렬할 때 나타난다.

### Sort Group By
Sort Group By는 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타난다.

오라클 10gR2 버전부터는 Group By 절 뒤에 Order By 절을 명시하지 않으면 대부분 Hash Group By 방식으로 처리한다.

### 그룹핑 결과의 정렬 순서
10gR2에서 Hash Group By가 도입되면서 정렬 순서를 보장하지 않게 되었다고 많이 알고 있다. 하지만 사실 오라클은 9i부터 이미 그룹핑 결과가 정렬 순서를 보장하지 않는다고 여러 문서를 통해 공식적으로 밝히고 있다.

그렇기 때문에 정렬된 그룹핑 결과를 얻고자 한다면, 실행계획에 설령 'Sort Grou By'라고 표시되더라도 `반드시 Order By를 명시해야 한다.`

### Sort Unique
Unnesting된 서브쿼리가 M쪽 집합이면, 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야 한다. 이때 Sort Unique 오퍼레이션이 나타난다.

만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장된다면, Sort Unique 오퍼레이션은 생략된다.

Union, Minus, Intersect 같은 집합 연산자, Distinct 연산자를 사용해도 Sort Unique 오퍼레이션이 나타난다.

### Sort Join
Sort Join 오퍼레이션은 소트 머지 조인을 수행할 때 나타난다.

### Window Sort
Window Sort는 윈도우 함수(분석 함수)를 수행할 때 나타난다.
