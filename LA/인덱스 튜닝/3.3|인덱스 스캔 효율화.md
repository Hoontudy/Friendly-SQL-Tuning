# 인덱스 탐색
인덱스 탐색은 수직적 탐색과 수평적 탐색의 과정을 거친다.

루트 블록에는 키 값을 갖지 않는 LMC라는 특별한 레코드가 존재한다. LMC가 가리키는 주소로 찾아간 블록에는 `키 값을 가진 첫 번째 레코드보다 작거나 같은 값`을 갖는 레코드가 저장돼 있다.

# 인덱스 스캔 효율성
인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.

### 인덱스 스캔 효율성 측정
인덱스 스캔 효율이 좋은지 나쁜지는 어떻게 알 수 있을까? 조건절 데이터를 일일이 조회해 보는 방법도 있지만, SQL 트레이스를 통해 쉽게 알 수 있다.
```sql
Rows    Row Source Operation
----    -------------------------------------------------------------------------
  10    TABLE ACCESS BY INDEX ROWID BIG_TABLE(cr=7471 pr=1466 pw=0 time=22137 us)
  10      INDEX RANGE SCAN BIG_TABLE_IDX(cr=7463 pr=1466 pw=0 time=22328 us)
```
해당 트레이스를 분석해 보면, 인덱스를 스캔하고 얻은 레코드가 10개인데, 그 과정에서 7,463개 블록을 읽었다는 사실을 알 수 있다. 리프 블록에는 테이블 블록보다 훨씬 더 많은 레코드가 담긴다. 한 블록당 평균 500개 레코드가 담긴다고 가정하면 10개의 레코드를 얻기 위해 3,731,500개 레코드를 읽은 셈이 된다.

# 엑세스 조건과 필터 조건
인덱스 스캔의 효율성을 이해하기 위해 중요한 두 가지 개념이 있다. `엑세스 조건`과 `필터 조건`이다.

![](https://velog.velcdn.com/images/tothek/post/124006d1-2857-41d2-bd72-d7fb5d277338/image.jpg)

인덱스를 스캔하는 단계에 처리하는 조건절은 엑세스 조건과 필터 조건으로 나뉜다. 

`인덱스 엑세스 조건은 인덱스 스캔 범위를 결정하는 조건절`이다. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절이다. 

`인덱스 필터 조건은 테이블로 엑세스할지를 결정하는 조건절`이다. 인덱스를 이용하든, 테이블을 Full Scan 하든, 테이블 엑세스 단계에서 처리되는 조건절은 모두 필터 조건이다. 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.

# 비교 연산자 종류와 컬럼 순서에 따른 군집성
테이블과 달리 `인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집`해 있다. '같은 값'을 찾을 때 '=' 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다. 어느 하나를 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.

선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다. 가장 선두 컬럼이 범위 검색 조건이면, 그 조건이 스캔 범위를 결정한다. 따라서 이들 조건이 인덱스 엑세스 조건이다. 나머지 인덱스 컬럼 조건은 모두 인덱스 필터 조건이다.

# 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
인덱스 스캔 효율성은 `인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.` 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 엑세스로 이어지므로 인덱스 스캔 단계에서의 비효율은 전혀 없다.

인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다. 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷 매물] 순으로 구성했을 때 조건절이 아래와 같은 경우를 말한다. 아래 조건절은 모두 인덱스 엑세스 조건으로 사용된다.
```sql
where 아파트시세코드 = :a
where 아파트시세코드 = :a and 평형 = :b
where 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c
where 아파트시세코드 = :a and 평형 = :b and 평형타입 between :c and :d
```
반면, 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

인덱스 선행 컬럼이 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, `조건을 만족하는 레코드가 모두 한데 모여 있기 때문`이다.

# BETWEEN을 IN-List로 전환
범위검색 컬럼이 맨 뒤로 가도록 인덱스를 변경하면 좋겠지만 운영 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다. 이럴 때 `BETWEEN 조건을 IN-List로` 바꿔주면 큰 효과를 얻는 경우가 있다.
```sql
/* between 사용 */
select 회원번호, 이름
from 회원
where 회원번호 between '1' and '3'
and 이름 = 'kim'

/* in 사용. in 절의 수 만큼 수직적 탐색을 한다. */
select 회원번호, 이름
from 회원
where 회원번호 in ('1', '2', '3')
and 이름 = 'kim'

/* 위 in 쿼리는 아래 쿼리처럼 동작한다. */
select 회원번호, 이름
from 회원
where 회원번호 = '1'
and 이름 = 'kim'
union all
select 회원번호, 이름
from 회원
where 회원번호 = '2'
and 이름 = 'kim'
union all
select 회원번호, 이름
from 회원
where 회원번호 = '3'
and 이름 = 'kim'
```
In-List 항목 개수가 늘어날 수 있다면 BETWEEN 을 IN-List로 전환하는 방식은 사용하기 곤란하다. 그럴 때는 `NL 방식의 조인문이나 서브쿼리로 구현`하면 된다.

### BETWEEN 조건을 IN-List로 전환할 때 주의 사항
BETWEEN 조건을 IN-List 조건으로 전환할 때 주의할 점은, `IN-List 개수가 많지 않아야 한다`는 것이다. IN-List 개수가 많으면 수직적 탐색이 많이 발생한다. 그러면 BETWEEN 조건 때문에 `리프 블록을 많이 스캔하는 비효율보다 IN-List 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있다.`

`인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용`하다. BETWEEN 조건절 범위 사이에 놓인 블록이 매우 소량이라면 수직적 탐색 때문에 오히려 블록 I/O가 더 많이 발생할 수 있기 때문이다.

# Index Skip Scan 활용
BETWEEN 조건을 IN-List 조건으로 바꾸지 않고, index_ss 힌트를 주어 Index Skip Scan을 유도하여도 비슷한 성능을 얻을 수 있다.

# IN 조건은 '='인가
IN 조건은 '='이 아니다. `IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다.` 그렇지 않으면, IN 조건은 필터 조건이다.

하지만 엑세스 조건을 만들기 위해 IN-List Iterator 방식으로 푸는 것이 항상 효과적인 것은 아니다. `데이터가 아주 많지 않은 경우에는 필터 방식으로 처리되는 게 오히려 낫다.`

### NUM_INDEX_KEYS 힌트 활용
```sql
/*+ num_index_keys(a 고객별가입상품_X1 1) */

힌트의 세 번째 인자 '1'은 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미다.
```

# BETWEEN과 LIKE 스캔 범위 비교
LIKE와 BETWEEN은 둘 다 범위검색 조건으로서, 앞에서 설명한 범위검색 조건을 사용할 때의 비효율 원리가 똑같이 적용된다. 하지만 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있다.

결론부터 말하면, LIKE보다 BETWEEN을 사용하는 게 낫다. 사용하기엔 BETWEEN이 다소 불편하지만 적어도 손해는 안 본다.
```sql
/* between */
where 가입일자 between '202201' and '202212'
and 회원코드 = 'A'
    
/* like */
where 가입일자 like '2022%'
and 회원코드 = 'A'
```
BETWEEN 조건절은 가입일자가 '202212' 이고 'B'인 첫 번째 레코드를 만나면 스캔을 종료한다. 반면 LIKE 조건절은 가입일자가 '202212'로 시작하는 모든 레코드를 다 읽고서야 스캔을 종료한다. 혹시라도 '202213'이 저장돼 있다면 그 값도 읽어야 하기 때문이다.

# 범위검색 조건을 남용할 때 생기는 비효율
코딩을 쉽게 하려고 인덱스 컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율이 생긴다. 인덱스 스캔 비효율이 성능에 미치는 영향이 적을 수도 있지만, 대량 테이블을 넒은 범위로 검색할 때는 그 영향이 매우 클 수도 있다. 따라서 SQL 작성할 때 주의해야 하며, `데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택`해야 한다.

# 다양한 옵션 조건 처리 방식의 장단점 비교
옵션 조건에 다양한 방식이 사용되는데, 각각의 장단점이 존재한다.

### OR 조건 활용
1. 인덱스 액세스 조건으로 사용 불가
2. 인덱스 필터 조건으로 사용 불가
3. 테이블 필터 조건으로만 사용 가능
4. 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 18c부터 인덱스 필터 조건으로 사용 가능
이 방식의 유일한 장점은 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과집합을 보장한다는 것뿐이다.

### LIKE/BETWEEN 조건 활용
LIKE/BETWEEN 패턴을 사용하고자 할 때는 아래 네 가지 경우에 속하는지 반드시 점검해야 한다. 
1. 인덱스 선두 컬럼 (LIKE/BETWEEN)
- 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물이다.
2. NULL 허용 컬럼 (LIKE/BETWEEN)
- 컬럼이 NULL 허용 컬럼이고 실제 NULL 값이 입력된다면 그 데이터는 결과 집합에서 누락된다.
3. 숫자형 컬럼 (LIKE)
- 자동 형변환으로 인해 필터 조건으로 사용된다. 
4. 가변 길이 컬럼 (LIKE)
- 컬럼 값 길이가 가변적일 때는 변수 값 길이가 같은 레코드만 조회되도록 조건절을 추가해야 한다.

### UNION ALL 활용
```sql
select * from 거래
where :cust_id is null
and 거래일자 between :dt1 and :dt2
union all
select * from 거래
where :cust_id is not null
and 거래일자 between :dt1 and :dt2
```
위 아래 SQL 중 어느 하나만 실행되게 하는 방식이다.

UNION ALL 방식은 `옵션 조건 컬럼도 인덱스 액세스 조건으로 사용`한다는 사실이 중요하다.

조건절의 컬럼이 NULL 허용 컬럼이더라도 사용하는 데 전혀 문제가 없다. 유일한 단점은 SQL 코드량 길어진다는 점이다.

### NVL/DECODE 함수 활용
- 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다. UNION ALL 보다 단순하면서도 같은 성능을 낸다.
- NULL 허용 컬럼에 사용할 수 없다는 단점이 있다.
- NVL/DECODE 함수를 여러개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다. 따라서 OR Expansion 기준으로 선택되지 않으면 인덱스 구성 컬럼이어도 모두 필터 조건으로 처리된다.

# 함수호출부하 해소를 위한 인덱스 구성
PL/SQL은 `SQL 구문을 절차적인 형태로(조건, 반복문 등) 프로그래밍이 가능하도록 한 것`이다.

PL/SQL 사용자 정의 함수가 느린 데는 3가지 이유가 있다.
1. 가상머신 상에서 실행되는 인터프리터 언어
- PL/SQL은 자바처럼 인터프리터 언어이기 때문에 Native 코드로 완전 컴파일된 내장 함수에 비해 많이 느리다.
2. 호출 시 마다 컨텍스트 스위칭 발생
- PL/SQL 함수는 실행 시 매번 SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 일어난다.
3. 내장 SQL에 대한 Recursive Call 발생
- 결과가 100만 건이면 함수도 100만 번 실행하는데, 만약 함수에 SQL이 내장돼 있으면 그 SQL도 100만 번 실행한다.

> 인덱스 구성을 잘 하면 함수 호출을 최소화 할 수 있다.
