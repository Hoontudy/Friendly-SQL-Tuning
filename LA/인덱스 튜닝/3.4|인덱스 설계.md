# 인덱스 설계가 어려운 이유
인덱스가 많으면 아래와 같은 문제가 발생한다.
- DML 성능 저하
- 데이터베이스 사이즈 증가
- 데이터베이스 관리 및 운영 비용 상승

### 진퇴양난 SQL 튜닝 - 개발 단계에서 최적 인덱스 설계의 중요성
인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 크다. 시스템 개발 단계에서 인덱스를 최적으로 설계하는 일이 무엇보다 중요한 이유가 바로 여기에 있다.

# 가장 중요한 두 가지 선택 기준
다양한 인덱스 스캔 방식 중 가장 정상적이고 일반적인 방식은 Index Range Scan이다. 이를 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다. 따라서 결합 인덱스를 구성할 때 첫 번째 기준은, `조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정`하는 것이다.

두 번째 기준은, 그렇게 `선정한 컬럼 중 '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다`는 것이다.

아래 두 가지 선택 기준을 공식처럼 외워두면 좋다.
1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.
2. '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

# 스캔 효율성 이외의 판단 기준
인덱스를 설계하기 위해서 위와 같은 조건 외에도 고려해야 할 사항이 많다.

- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하
- 저장 공간
- 인덱스 관리 비용 등

이런 다양한 판단 기준에 대한 해석이 서로 다르기 때문에 설계자의 성향이나 스타일에 따라 결과물들도 크게 달라진다.

이 중 가장 중요한 하나를 꼽으라면 수행 빈도가 아닐까 싶다. 수행빈도가 매우 높은 SQL에는 인덱스 공식을 이용하여 최적의 인덱스를 구성해 줘야 한다.

수행빈도와 관련해, NL 조인할 때 어느 쪽에서 자주 엑세스 되는지도 중요한 판단 기준이 된다.

NL 조인할 때 Outer 쪽에서 엑세스하는 인덱스는 스캔 과정에 비효율이 있더라도 큰 문제가 아닐 수 있다.

반대로, NL 조인에서 Inner 쪽 인덱스 스캔 과정에 비효율이 발생할 경우, 이는 성능에 큰 문제를 야기할 수 있다.

수행빈도가 매우 높은 SQL이라면, 테스트 과정에 당장 성능이 좋게 나오더라도 인덱스를 최적으로 구성해 줘야 한다. `NL 조인 Inner 쪽 인덱스는 '=' 조건 컬럼을 선두에 두는 것이 중요하고, 될 수 있으면 테이블 엑세스 없이 인덱스에서 필터링을 마치도록 구성해야 한다.`

데이터량도 인덱스를 설계할 때 중요한 판단 기준이다. 데이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없다. Full Scan으로도 충분히 빠르기 때문이다.  

# 공식을 초월한 전략적 설계
SQL 튜닝 전문가라면, 열 개 중 최적을 달성해야 할 가장 `핵심적인 엑세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계`하고, 나머지 엑세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다.
> 💡 단순한 공식에 의한 결정이 아니라, 업무 상황을 이해하고 나름의 판단 기준을 가지고 결정을 해야한다.

예를 들어, 어떤 보험사에 '가계약' 테이블이 있다. 가계약 목록을 조회할 때 다양한 방식으로 조회한다. 우선, 드롭다운 리스트에서 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택한다. 조건절 연산자는 '='이다. 그리고 네 개 일자/일시 중 하나를 선택한다. 조건절 연산자는 BETWEEN이다.

![](file:///Users/kinseonghyeon/Desktop/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-11-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.09.18.png)

이런 상황에서 인덱스 스캔 효율을 위해 '=' 조건 컬럼을 앞에, BETWEEN 조건 컬럼을 뒤에 두려면 24개 인덱스가 필요하다. 가계약 테이블에는 INSERT가 매우 많이 발생하는데, 과연 인덱스를 24개나 만들 것인가? 전략적인 판단이 필요하다.

아래와 같이 설계하면 어떨까? 일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식이다.

- X01 : 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X02 : 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X03 : 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- X04 : 데이터생성일시 + 취급부서 + 취급지점 + 취급자 + 대리점설계사 + 대리점지사

이렇게 설계한 핵심 포인트는 두 가지다. 첫째, 일자 조회구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다는 점이다. 둘째, 인덱스 스캔 효율보다 테이블 엑세스가 더 큰 부하요소라는 점이다.

`가계약은 주로 최근 3일 이내 데이터를 조회`한다. 대개는 전일자로 조회하므로 인덱스 스캔량은 그리 많지 않다. 가끔 3일을 초과한 기간으로 조회할 수 있고, 어쩌다 한 달 치를 조회할 수도 있다. 그렇더라도 불필요한 테이블 엑세스는 전혀 발생하지 않도록 설계했으므로 사용자가 인내할 수 있는 수준의 성능은 낼 수 있다.

사용자가 인내할 수 있는 수준의 인덱스 스캔 비효율이더라도 BETWEEN 조건 컬럼을 선두에 두고 설계하는 것은 좀 찜찜하다. 그런데도 이런 결정을 한 이유는 따로 있다. 가계약 테이블을 다양한 패턴으로 조회하지만, 그중 가장 많이 사용(85% 이상)하는 패턴은 입력자 ‘=’, 데이터생성일시 BETWEEN 조건이기 때문이다. 따라서 이 패턴에 최적의 스캔 효율을 제공하면, 다른 패턴에 다소 비효율이 있어도 업무에 크게 지장이 없다고 판단한 것이다.

앞서 설계한 네 개 인덱스에 아래 인덱스를 하나 더 추가하자, (X04 인덱스에 입력자 컬럼은 누락된 것이 아니라 이 인덱스가 있어서 일부러 뺐다.)

- X05 : 입력자 + 데이터생성일시

이렇게 인덱스 개수를 최소화하면, 사용빈도가 높거나 중요한 인덱스 경로가 새로 도출됐을 때 최적의 인덱스를 추가할 여유도 생긴다.

# 소트 연산을 생략하기 위한 컬럼 추가
인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해 준다. 따라서 `조건절에 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.`

아래 쿼리에 ORDER BY 절이 있음에도 불구하고 소트 연산이 발생하지 않도록 인덱스를 구성해 보자.

```sql
select 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점ID = :trt_brch_id
and 청약일자 between :sbcp_dt1 and :sbcp_dt2
and 입력일자 >= trunc(sysdate - 3)
and 계약상태코드 in (:ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3)
order by 청약일자, 입력자ID
```

성능을 고려하지 않아도 된다면, ORDER BY 절 순서대로 '청약일자 + 입력자ID'로 구성하면 된다.

`'=' 조건절 컬럼은 ORDER BY 절에 없더라도 인덱스 구성에 포함할 수 있다.` 위 SQL에선 취급지점ID가 '=' 조건이다. 이를 포함해 '청약일자 + 취급지점ID + 입력자 ID' 순으로 구성해도 소트 연산을 생략할 수 있다는 뜻이다. 위치는 앞뒤 중간 어디에 두어도 상관없다.

`'='이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.`

인덱스를 그렇게 구성하면 일단 소트는 생략할 수 있다. 문제는 성능인데, 조건을 만족하는 데이터를 빨리 만날 수 있느냐가 관건이다.

I/O를 최소화하면서도 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.
1. '=' 연산자로 사용한 조건절 컬럼 선정
2. ORDER BY 절에 기술한 컬럼 추가
3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

이 공식에 따라 위에서 제시한 SQL에는 인덱스를 '취급지점ID + 청약일자 + 입력자ID' 순으로 구성한다.

### IN 조건은 '='이 아니다.
IN 조건은 '=' 이 아니다.
```sql
select 고객번호, 고객명, 거주지역, 혈액형, 연령 
from 고객
where 거주지역 = '서울'
and 혈액형 in ('A', 'O')
order by 연령
```
`IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야 한다.` IN-List Iterator 방식으로 푼다는 건 SQL을 아래와 같은 방식으로 실행한다는 의미이다. 그러면 IN 조건이 '='이 됐지만, UNION ALL 위아래 두 집합을 묶어 '연령' 순으로 정렬하는 문제가 남는다.
```sql
select 고객번호, 고객명, 거주지역, 혈액형, 연령 
from 고객
where 거주지역 = '서울'
and 혈액형 = 'A'
union all
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 = '서울'
and 혈액형 = 'O'
order by 연령
```
해당 SQL에서 소트 연산을 생략하려면, 서울에 거주하는 모든 'A'형 고객이 'O'형 고객보다 연령이 낮아야 한다. 이것은 불가능한 일이다.

결론적으로, `소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안 된다.` 즉, IN 조건절을 인덱스 엑세스 조건으로 사용하면 안 된다. 필터 조건으로 사용해야 한다. 따라서 인덱스를 '거주지역 + 연령 + 혈액형' 순으로 구성해야 한다.

# 결합 인덱스 선택도
인덱스 생성 여부를 결정할 때는 `선택도가 충분히 낮은지가 중요한 판단기준`이다. 선택도란, `전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율`을 말하며, 선택도에 총 레코드 수를 곱해서 '카디널리티'를 구한다.
인덱스 선택도는 `인덱스 컬럼을 모두 '='로 조회할 때 평균적으로 선택되는 비율`을 의미한다. 선택도가 높은 인덱스는 생성해봐야 효용가치가 별로 없다. `테이블 엑세스가 많이 발생하기 때문`이다.

# 중복 인덱스 제거
아래 세 인덱스는 중복이다. X02 인덱스 선두 컬럼이 X01 인덱스 전체를 완전히 포함하고, X03 인덱스 선두 컬럼이 X01과 X02 인덱스 전체를 완전히 포함하기 때문이다. 필자는 이를 `완전 중복`이라고 부른다고 한다. X03 인덱스를 남기고, X01, X02 인덱스를 삭제해도 된다.

- X01 : 계약ID + 청약일자
- X02 : 계약ID + 청약일자 + 보험개시일자
- X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

아래 네 개 인덱스는 얼핏 보기엔 중복이 아니다. 선두 컬럼은 같지만, 두 번째 컬럼이 모두 다르기 때문이다.
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 보험개시일자
- X03 : 계약ID + 보험종료일자
- X04 : 계약ID + 데이터생성일시

하지만, 계약ID의 `평균 카디널리티가 매우 낮다면 사실상 중복`이다. 예를 들어, 계약ID 평균 카디널리티가 5라고 가정하자. 계약ID를 ‘=’조건으로 조회하면, 평균 다섯 건이 조회된다는 뜻이다. 그렇다면 이렇게 인덱스를 네 개씩이나 만들 이유가 없다. 아래와 같이 하나만 만들면 충분하다. 필자는 `완전중복`과 대비해 이를 `불완전 중복`이라고 한다.

- X01 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시

