# 테이블 랜덤 엑세스
### 인덱스 ROWID는 물리적 주소? 논리적 주소?
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후에 반드시 테이블을 엑세스한다.

인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, ROWID를 얻으려는 데 있다.

그렇다면 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까? 데이터파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소로 구성돼 있기 때문에 물리적 주소라고 생각할 수 있다. 하지만 `ROWID는 논리적 주소에 더 가깝다.` 물리적으로 직접 연결되어 있지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문이다.
> ROWID는 포인터와 전혀 상관없다.

### 메인 메모리 DB와 비교
메인 메모리 DB는 말 그대로 `데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB`라고 할 수 있다. 그런데 잘 튜닝된 OLTP성 데이터베이스 시스템이라면 버퍼캐시 히트율이 99% 이상이다. 디스크를 경유하지 않고 대부분 데이터를 메모리에서 읽는다는 뜻이다. 그런데도 `메인 메모리 DB만큼 빠르지는 않다.` 특히 대량 데이터를 인덱스로 엑세스할 때 엄청난 차이가 나는데 왜 그럴까?

메인 메모리 DB는 디스크 저장 데이터를 버퍼캐시로 로딩하고 인덱스를 생성한다. 이때 인덱스는 디스크 상의 주소정보가 아닌 메모리상의 주소정보를(포인터) 갖는다.

반면, 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조이다. 그렇기 때문에 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

> 인덱스 ROWID를 이용한 테이블 엑세스는 생각만큼 빠르지 않다.

### I/O 메커니즘 복습
`I/O 성능을 높이려면 버퍼캐시를 활용해야 한다.` 그래서 블록을 읽을 때는 디스크로 가기 전에 버퍼캐시부터 찾아본다. 읽고자 하는 DBA를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.

설령 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 `매번 DBA 해싱과 래치 획득 과정을 반복`해야 한다. 동시 엑세스가 심할 때는 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.

이처럼 인덱스 `ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조`이다.

### 인덱스 ROWID는 우편주소
디스크 DB(오라클, SQL Server...)가 사용하는 ROWID를 우편주소에, 메인 메모리 DB가 사용하는 포인터를 전화번호에 비유할 수 있다. `전화 통신은 물리적으로 연결된 통신망을 이용하므로 전화번호를 누르면 곧바로 상대방과 통화할 수 있다. 하지만, 우편통신은 봉투에 적힌 대로 우체부 아저씨가 일일이 찾아다니는 구조이므로 전화와는 비교할 수 없이 느리다.`

# 인덱스 클러스터링 팩터
클러스터링 팩터는 `특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미`한다. 

클러스터링 팩터가 좋은 경우 `인덱스 정렬 순서와 테이블 레코드 정렬 순서가 일치`하기 때문에 검색 효율이 매우 좋다. 반면, 클러스터링 팩터가 좋지 않은 경우 인덱스 정렬 순서와 테이블 레코드 정렬 순서가 일치하지 않아 검색 효율이 떨어진다.

# 인덱스 손익분기점
인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다. 따라서 `읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.` Index Ragne Scan이 Table Full Scan보다 느려지는 지점을 흔히 '인덱스 손익분기점' 이라고 부른다.

`Table Full Scan은 데이터 갯수 상관 없이 성능이 일정`하다. 반면, `인덱스를 이용해 테이블을 엑세스할 때는 추출 건수에 따라 성능이 크게 달라진다.`

인덱스를 이용한 테이블 엑세스가 Table Full Scan보다 더 느려지게 만드는 가장 핵심적인 두 가지 요인은 다음과 같다.
- Table Full Scan은 시퀀셜 엑세스인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 랜덤 엑세스 방식이다.
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 Single Block I/O 방식이다.

> 테이블 스캔이 항상 나쁜 것은 아니다. 바꿔 말해 인덱스 스캔이 항상 좋은 것도 아니다.

### 온라인 프로그램 튜닝 vs. 배치 프로그램 튜닝
온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다. 조인도 대부분 NL 방식을 사용한다. NL 조인은 인덱스를 이용하는 조인 방식이다. 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면, 온라인 환경에서 대량 데이터를 조회할 때도 아주 빠른 응답 속도를 낼 수 있다.

반면, 대량 데이터를 읽고 갱신하는 배치(Batch) 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다. 즉, 처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다. 대량 데이터를 빠르게 처리하려면, 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다.

# 인덱스 컬럼 추가
인덱스를 수정하기에는 해당 인덱스를 사용하는 쿼리가 존재할 수 있다. 인덱스를 새로 만드는 방법도 있다. 하지만 이럴 때 마다 인덱스를 계속 추가하다 보면 인덱스 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.

테이블 엑세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 `인덱스에 컬럼을 추가하는 것`이다.

`인덱스 스캔량은 줄지 않지만, 테이블 랜덤 엑세스 횟수를 줄여주기 때문`이다.

# 인덱스만 읽고 처리
인덱스만 읽어서 처리하는 쿼리를 ‘Covered 쿼리’라고 부르며, 그 쿼리에 사용한 인덱스를 ‘Covered 인덱스’라고 부른다.

# 인덱스 구조 테이블
인덱스 구조 테이블은 `랜덤 엑세스가 절대 발생하지 않도록 데이터를 인덱스 리프 블록에 모두 저장하는 방식`이다.

테이블을 인덱스 구조로 만드는 구문
```sql
create table index_org_t (
    a number, 
    b varchar(10),
    constraint index_org_t_pk primary key (a) )
organization index; /*인덱스를 만들 때 해당 키워드를 붙여준다.*/
```
인덱스 구조 테이블은 `인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나`이다. 같은 값을 가진 레코드들이 `100% 정렬`된 상태로 모여 있으므로 랜덤 엑세스가 아닌 시퀀셜 방식으로 데이터를 엑세스한다. 이 때문에 `BETWEEN이나 부등호 조건으로 넓은 범위를 읽을 때 유리`하다.

# 클러스터 테이블
클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.

### 인덱스 클러스터 테이블
인덱스 클러스터 테이블은 `클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조`이다. 

클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다. 따라서 클러스터 인덱스의 키 값은 항상 유니크하다.

이런 구조적 특성 때문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 엑세스가 (클러스터 체인을 스캔하면서 발생하는 랜덤 엑세스는 제외하고) 값 하나당 한 번씩 밖에 발생하지 않는다.

### 해시 클러스터 테이블
해시 클러스터는 인덱스를 사용하지 않고 `해시 알고리즘을 사용해 클러스터를 찾아간다.`
